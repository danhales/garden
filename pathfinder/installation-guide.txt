# Pathfinder Installation Guide

## Setup Instructions

1. Create the project structure:

```bash
mkdir -p pathfinder/core pathfinder/ui pathfinder/static/css
touch pathfinder/__init__.py pathfinder/app.py
touch pathfinder/core/__init__.py pathfinder/core/models.py pathfinder/core/managers.py
touch pathfinder/ui/__init__.py pathfinder/ui/themes.py pathfinder/ui/accessibility.py
```

2. Copy the code from each file into the corresponding file in your project structure.

3. Install required dependencies:

```bash
pip install flask neo4j
```

## Running the Application

### As a Script

```bash
python -m pathfinder
```

### As a Flask Application

```bash
# Set environment variables
export FLASK_APP=pathfinder.app:create_app
export FLASK_ENV=development

# Run Flask
flask run --host=0.0.0.0 --port=5000
```

## Error Analysis

The error you encountered had two issues:

1. **Path Name Collision**: In your original code, you used `Path` as your class name, but also imported `Path` from the `pathlib` module. This caused a naming conflict. I renamed your class to `PathRoute` to fix this.

2. **Flask App Factory**: The error `Failed to find Flask application or factory in module 'pathfinder'` occurred because Flask couldn't find the application object. The restructured code uses an application factory pattern (`create_app()`) which needs to be specified in the FLASK_APP environment variable.

## Testing the Application

1. **Basic testing**:

```python
# Test basic initialization
from pathfinder import Pathfinder

pf = Pathfinder()
print("Pathfinder initialized successfully")

# Create a test context
context = pf.context_manager.create_context(
    name="Test Context",
    description="A test context for movie data"
)
print(f"Created context: {context.name}")

# Test theme manager
themes = pf.theme_manager.list_themes()
print(f"Available themes: {[t['name'] for t in themes]}")
```

2. **Test with Neo4j movie graph**:

```python
# Import data from Neo4j movie graph
# Assuming you've loaded the movie graph in Neo4j and generated a module

# Generate the module first
pf.generate_module(name="movie_graph")

# Import Person nodes
pf.context_manager.import_from_graph_module(
    "movie_graph.py", 
    "Person", 
    limit=10
)

# Import Movie nodes
pf.context_manager.import_from_graph_module(
    "movie_graph.py", 
    "Movie", 
    limit=20
)

# Check imported data
current_context = pf.context_manager.contexts[pf.context_manager.current_context_id]
print(f"Imported {len(current_context.nodes)} nodes")

# Create a visualization
viz_data = pf.context_manager.visualize_context()
print(f"Visualization contains {len(viz_data['nodes'])} nodes and {len(viz_data['links'])} links")
```

3. **Create actor-centric and director-centric contexts**:

```python
# Create actor context
actor_context = pf.context_manager.create_context(
    name="Tom Hanks",
    description="Actor-centric view of Tom Hanks' movies"
)
pf.context_manager.switch_context(actor_context.id)

# Import Tom Hanks and related movies
pf.context_manager.import_from_graph_module(
    "movie_graph.py", 
    "Person:Actor:Tom_Hanks", 
    limit=1
)
pf.context_manager.import_from_graph_module(
    "movie_graph.py", 
    "Movie", 
    limit=10
)

# Create director context
director_context = pf.context_manager.create_context(
    name="Steven Spielberg",
    description="Director-centric view of Spielberg's movies"
)
pf.context_manager.switch_context(director_context.id)

# Import Spielberg and related movies
pf.context_manager.import_from_graph_module(
    "movie_graph.py", 
    "Person:Director:Steven_Spielberg", 
    limit=1
)
pf.context_manager.import_from_graph_module(
    "movie_graph.py", 
    "Movie", 
    limit=10
)

# Compare contexts
comparison = pf.context_manager.compare_contexts(actor_context.id, director_context.id)
print(comparison['accessibility_summary'])
```

## Accessibility Features

The rewritten application includes several accessibility improvements:

1. **Screen reader support**: All nodes, relationships, and contexts include descriptive labels
2. **Keyboard navigation**: Graph nodes can be navigated using keyboard 
3. **High contrast theme**: Available through the UI or API
4. **Reduced motion support**: Respects user preferences for reduced animations
5. **Skip links**: Allows keyboard users to skip to main content
6. **ARIA attributes**: Proper landmarks and roles for screen readers
7. **Accessible text**: Descriptions generated automatically for screen readers

## Next Steps

Consider these improvements for future development:

1. Implement full graph visualization with SVG and proper keyboard navigation
2. Add audio feedback for context transitions
3. Create a unified configuration system
4. Develop more accessibility testing tools
5. Add advanced Neo4j query capabilities 
6. Implement path analysis algorithms