<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodePad v1.üå≥1.0</title>
    <!-- 
        NodePad v1.üå≥1.0: Visual Knowledge Network
        
        Version History:
        v0.0.1 - Initial implementation with popup editor and basic node display
        v0.0.2 - Attempted to refactor with Node class architecture (contained bugs)
        v0.0.3 - Fixed edge rendering bug and simplified architecture
        v0.0.4 - Restructured code with proper DocTrellis versioning and modularized components
        v0.0.5 - Fixed node interaction bug with dragging different nodes
        v0.0.6 - Implemented template-based node rendering system
        v0.0.7 - Added ability to edit node names
        v0.1.0 - First minor version with stable core features and cleaned documentation
        v1.0.0 - Complete constructivist rewrite with knot-compacted architecture
        v1.ü™¥1.0 - Simplified circular nodes with emoji identifiers and hover information
        v1.üåø1.1 - Enhanced node display with emoji/title toggle and fixed emoji picker width
        v1.üå≥1.0 - Stable release with independent emoji/title controls, node coloring, smart positioning,
                 node removal, and JSON import functionality
        
        DocTrellis Feature Status:
        üå≥ Core Architecture - Tree - Constructivist template system with metadata-driven design
        üå≥ Node Management - Tree - Create, select, edit, remove, and drag nodes
        üåø Edge Connections - Herb - Connections between nodes
        üå≥ Network View - Tree - Canvas-based visualization with independent emoji/title display options
        üåø Node Customization - Herb - Colors and emoji selection for visual organization
        üå± Import/Export - Seedling - JSON export and import functionality
        
        Leaf Pile (Pruned Features):
        üçÇ CSV Export - Removed to simplify data handling
        üçÇ Source Explorer - Browser-based source code exploration using emoji markers
        üçÇ Custom node styles - Multiple visual presentation options for node content
        üçÇ Static Tooltips - Replaced with more contextual information displays
        üçÇ Fixed Node Sizing - Replaced with dynamic sizing based on content and display mode
    -->
    <style>
        /* Base Variables - Single Source of Truth */
        :root {
            /* Color Palette */
            --color-bg: #fafafa;
            --color-surface: #ffffff;
            --color-surface-alt: #f5f5f5;
            --color-border: #dddddd;
            --color-text: #333333;
            --color-text-muted: #666666;
            --color-primary: #1890ff;
            --color-primary-dark: #096dd9;
            --color-primary-light: #e6f7ff;
            --color-success: #52c41a;
            --color-warning: #faad14;
            --color-error: #f5222d;
            
            /* Spacing System */
            --space-unit: 8px;
            --space-xs: calc(var(--space-unit) * 0.5);  /* 4px */
            --space-sm: var(--space-unit);              /* 8px */
            --space-md: calc(var(--space-unit) * 2);    /* 16px */
            --space-lg: calc(var(--space-unit) * 3);    /* 24px */
            --space-xl: calc(var(--space-unit) * 4);    /* 32px */
            
            /* Typography */
            --font-family: Arial, sans-serif;
            --font-size-base: 14px;
            --font-size-sm: 12px;
            --font-size-lg: 16px;
            --font-weight-normal: 400;
            --font-weight-bold: 600;
            --line-height: 1.6;
            
            /* Layout */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            
            /* Node dimensions */
            --node-size: 60px;
            --node-emoji-size: 24px;
            
            /* Animation */
            --animation-duration: 300ms;
            --animation-easing: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            color: var(--color-text);
            background-color: var(--color-bg);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Application Layout */
        .header {
            background-color: var(--color-surface);
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            margin: 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .version {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            font-weight: var(--font-weight-normal);
            margin-left: var(--space-sm);
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--color-bg);
        }
        
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .editor-container {
            width: 40%;
            display: flex;
            flex-direction: column;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            overflow: hidden;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: var(--space-sm);
            flex-wrap: wrap;
        }
        
        button {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-surface-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: var(--font-size-base);
            transition: background-color var(--transition-fast);
            white-space: nowrap;
        }
        
        button:hover {
            background-color: var(--color-border);
        }
        
        button:active {
            background-color: var(--color-border);
        }
        
        button.primary {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        button.primary:hover {
            background-color: var(--color-primary-dark);
        }
        
        button.danger {
            background-color: var(--color-error);
            color: white;
            border-color: var(--color-error);
        }
        
        button.danger:hover {
            background-color: #d9363e;
        }
        
        /* Editor Styles */
        .editor-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface-alt);
        }
        
        .editor-title {
            margin: 0 0 var(--space-xs) 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .node-emoji {
            font-size: 1.2em;
        }

        .unused-class {
            font-size: 1em;
        }
        
        .editor-subtitle {
            color: var(--color-text-muted);
            font-size: var(--font-size-base);
            margin: 0;
        }
        
        .editor-content {
            flex: 1;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-placeholder {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-muted);
            font-style: italic;
            text-align: center;
            padding: var(--space-lg);
        }
        
        .name-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        .emoji-input-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }
        
        .emoji-label, .color-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        #node-emoji-select {
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-lg);
            min-width: 60px;
            cursor: pointer;
        }
        
        #node-name {
            width: 100%;
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            transition: border-color var(--transition-fast);
        }
        
        #node-name:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        #node-content {
            flex: 1;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            resize: none;
            margin-bottom: var(--space-md);
        }
        
        #node-content:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        .editor-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Node tooltip */
        .node-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-sm);
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity var(--transition-fast);
            max-width: 200px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Status Indicator */
        .status {
            position: absolute;
            bottom: var(--space-sm);
            left: var(--space-sm);
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-base);
            color: var(--color-text-muted);
        }

        /* Emoji picker dialog */
        .emoji-picker {
            position: absolute;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            padding: var(--space-md);
            z-index: 100;
            /* Dynamic width will be calculated in JS */
            display: none;
        }
        
        .emoji-picker.active {
            display: block;
        }
        
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }
        
        .emoji-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            border-radius: var(--border-radius-sm);
        }
        
        .emoji-item:hover {
            background-color: var(--color-surface-alt);
        }
        
        /* Color picker styles */
        .color-picker {
            position: absolute;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            padding: var(--space-md);
            z-index: 100;
            display: none;
            width: 280px;
        }
        
        .color-picker.active {
            display: block;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-sm);
            margin-bottom: var(--space-sm);
        }
        
        .color-item {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid var(--color-border);
            transition: transform var(--transition-fast);
        }
        
        .color-item:hover {
            transform: scale(1.1);
        }
        
        .color-item.active {
            border: 2px solid var(--color-primary);
        }
        
        .custom-color-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-top: var(--space-md);
        }
        
        #custom-color {
            padding: 0;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            width: 30px;
            height: 30px;
            cursor: pointer;
        }
        
        /* Display mode toggles */
        .display-toggles {
            display: flex;
            gap: var(--space-md);
            align-items: center;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--color-border);
            border-radius: 10px;
            transition: var(--transition-fast);
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            border-radius: 50%;
            transition: var(--transition-fast);
        }
        
        input:checked + .toggle-slider {
            background-color: var(--color-primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        .toggle-label {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
        }
        
        /* Node color selector */
        .color-select-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        #node-color-select {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid var(--color-border);
            cursor: pointer;
        }
        
        /* File import styles */
        .file-input {
            display: none;
        }
        
        /* Responsive styles */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .editor-container {
                width: 100%;
                height: 40%;
                border-left: none;
                border-top: 1px solid var(--color-border);
            }
            
            .controls {
                flex-wrap: wrap;
            }
        }
        
        /* Node removal confirmation modal */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal);
        }
        
        .modal-backdrop.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            width: 400px;
            max-width: 90%;
            transform: translateY(-20px);
            transition: transform var(--transition-normal);
        }
        
        .modal-backdrop.active .modal {
            transform: translateY(0);
        }
        
        .modal-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
        }
        
        .modal-title {
            margin: 0;
            font-size: var(--font-size-lg);
            color: var(--color-error);
        }
        
        .modal-body {
            padding: var(--space-md);
        }
        
        .modal-footer {
            padding: var(--space-md);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">üìù NodePad <span class="version">v1.üå≥1.0</span></h1>
        <div class="controls">
            <button id="add-node-btn">Add Node</button>
            <div class="display-toggles">
                <div class="toggle-container">
                    <span class="toggle-label">Emoji</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="emoji-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">Titles</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="title-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            <button id="export-json-btn">Export JSON</button>
            <button id="import-json-btn">Import JSON</button>
            <input type="file" id="import-file" class="file-input" accept=".json">
        </div>
    </div>
    
    <div class="main-container">
        <!-- Network View (Left Side) -->
        <div class="canvas-container">
            <canvas id="network-canvas"></canvas>
            <div class="node-tooltip" id="node-tooltip"></div>
            <div class="status" id="status">Ready</div>
        </div>
        
        <!-- Node Editor (Right Side) -->
        <div class="editor-container">
            <div class="editor-header">
                <h2 class="editor-title" id="editor-title">Node Editor</h2>
                <p class="editor-subtitle" id="editor-subtitle">Select a node to edit its content</p>
            </div>
            
            <div class="editor-content" id="editor-content">
                <div class="editor-placeholder" id="editor-placeholder">
                    Click on a node in the network view to edit its content
                </div>
                
                <div class="emoji-input-container">
                    <div>
                        <label class="emoji-label" for="node-emoji-select">Node Icon:</label>
                        <button id="node-emoji-select">üå±</button>
                    </div>
                    <div class="color-select-container">
                        <label class="color-label" for="node-color-select">Color:</label>
                        <div id="node-color-select" style="background-color: #ffffff;"></div>
                    </div>
                    <div style="flex: 1;">
                        <label class="name-label" for="node-name">Node Title:</label>
                        <input type="text" id="node-name" placeholder="Enter a title for this node">
                    </div>
                </div>
                
                <textarea id="node-content" placeholder="Enter your notes here..."></textarea>
                
                <div class="editor-actions">
                    <button id="remove-node-btn" class="danger">Remove Node</button>
                    <button id="update-node-btn" class="primary">Update Node</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Emoji Picker Dialog -->
    <div class="emoji-picker" id="emoji-picker">
        <h3>Select an Emoji</h3>
        <div class="emoji-grid" id="emoji-grid"></div>
    </div>
    
    <!-- Color Picker Dialog -->
    <div class="color-picker" id="color-picker">
        <h3>Select a Color</h3>
        <div class="color-grid" id="color-grid"></div>
        <div class="custom-color-container">
            <label for="custom-color">Custom color:</label>
            <input type="color" id="custom-color" value="#ffffff">
        </div>
    </div>
    
    <!-- Confirmation Modal for Node Removal -->
    <div class="modal-backdrop" id="remove-confirmation-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Remove Node?</h3>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to remove this node and all its connections? This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button id="cancel-remove-btn">Cancel</button>
                <button id="confirm-remove-btn" class="danger">Remove</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * NodePad v1.üå≥1.0: Visual Knowledge Network
         * 
         * A nonlinear note-taking application that represents ideas as 
         * interconnected nodes in a visual network, making it easier to
         * organize complex thoughts and relationships.
         * 
         * @version 1.üå≥1.0
         */
        
        document.addEventListener('DOMContentLoaded', function() {
            // =====================================================================
            // META-SYSTEM: Application Metadata and Configuration
            // =====================================================================

            /**
             * META: Application knowledge system
             * 
             * Centralized configuration that serves as a single source of truth
             * for all application parameters.
             * 
             * @version 1.üå≥1.0 - Enhanced with independent display controls and color options
             */
            const META = {
                /** Application version information */
                version: {
                    number: '1.üå≥1.0',
                    name: 'Visual Knowledge Network',
                    date: '2025-03-31'
                },
                
                /** Debug configuration */
                debug: {
                    enabled: true,
                    prefix: 'NodePad',
                    levels: {
                        info: '‚ÑπÔ∏è',
                        warn: '‚ö†Ô∏è',
                        error: '‚ùå',
                        success: '‚úÖ'
                    }
                },
                
                /** Node configuration */
                node: {
                    defaults: {
                        size: 60,
                        emoji: 'üå±',
                        content: '',
                        color: '#ffffff' // Default white background
                    },
                    selected: {
                        outlineWidth: 3,
                        outlineColor: '#1890ff'
                    },
                    dragThreshold: 5,  // Pixels of movement needed to start dragging
                    
                    // Display configuration with independent controls
                    display: {
                        emojiVisible: true,
                        titleVisible: false,
                        transition: {
                            duration: 300, // ms
                            easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
                        },
                        title: {
                            fontSize: 0.3, // proportion of node size
                            minWidth: 1.0, // proportion of node size
                            padding: 0.25 // proportion of node size
                        },
                        emoji: {
                            size: 0.4 // proportion of node size
                        }
                    },
                    
                    // Positioning logic
                    positioning: {
                        // Horizontal spacing (for compact emoji view)
                        horizontalOffset: 2, // multiplier of node size
                        // Vertical spacing (for expanded title view)
                        verticalOffset: 1.5, // multiplier of node size
                    },
                    
                    // Color options
                    colors: [
                        '#ffffff', // White (default)
                        '#f0f4c3', // Light yellow
                        '#c8e6c9', // Light green
                        '#bbdefb', // Light blue
                        '#d1c4e9', // Light purple
                        '#ffccbc', // Light orange
                        '#ffcdd2', // Light red
                        '#e1bee7', // Light pink
                        '#b2dfdb', // Light teal
                        '#f5f5f5'  // Light gray
                    ]
                },
                
                /** Edge configuration */
                edge: {
                    style: {
                        color: '#d9d9d9',
                        width: 1,
                        selectedColor: '#1890ff',
                        selectedWidth: 2
                    }
                },
                
                /** Export/Import configuration */
                dataTransfer: {
                    formats: {
                        json: {
                            extension: 'json',
                            contentType: 'application/json',
                            filename: 'nodepad-network.json'
                        }
                    }
                },
                
                /** Emoji picker configuration */
                emojiPicker: {
                    emojis: [
                        'üå±', 'üåø', 'üå≥', 'üçÇ', 'üîÆ', 'üìù', 'üí°', 'üîç', 
                        'üìä', 'üìà', 'üìâ', 'üìå', 'üîñ', 'üìö', 'üóÇÔ∏è', 'üìã',
                        '‚úÖ', '‚ùå', '‚ö†Ô∏è', '‚ùì', '‚ùó', 'üí¨', 'üó®Ô∏è', 'üîÑ',
                        'üß©', '‚öôÔ∏è', 'üîß', 'üî®', '‚è±Ô∏è', 'üìÖ', 'üß†', '‚ù§Ô∏è'
                    ],
                    columns: 8, // Number of columns in the grid
                    itemSize: 30, // Size of each emoji item in pixels
                    padding: 16 // Padding inside the container in pixels
                },
                
                /** Animation configuration */
                animation: {
                    duration: 300, // ms
                    easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
                },
                
                /** Templates for static text */
                templates: {
                    welcome: {
                        emoji: 'üìù',
                        name: 'Welcome to NodePad!',
                        content: 'This is your first note in your visual knowledge network.\n\n‚Ä¢ Click nodes to edit their content\n‚Ä¢ Drag nodes to rearrange them\n‚Ä¢ Connect nodes to show relationships\n‚Ä¢ Customize nodes with colors and emojis\n‚Ä¢ Toggle between emoji and title views\n\nStart organizing your ideas!',
                        color: '#bbdefb' // Light blue for welcome node
                    },
                    status: {
                        ready: 'Ready',
                        selected: nodeName => `Selected: ${nodeName}`,
                        created: nodeName => `Created: ${nodeName}`,
                        updated: nodeName => `Updated: ${nodeName}`,
                        removed: nodeName => `Removed: ${nodeName}`,
                        exported: format => `Exported ${format} file`,
                        imported: fileInfo => `Imported ${fileInfo}`,
                        displayChanged: mode => `Display mode updated`
                    },
                    modals: {
                        removeNode: {
                            title: 'Remove Node?',
                            message: 'Are you sure you want to remove this node and all its connections? This action cannot be undone.',
                            cancel: 'Cancel',
                            confirm: 'Remove'
                        }
                    }
                }
            };
            
            // =====================================================================
            // TEMPLATES: Reusable Object Factories
            // =====================================================================

            /**
             * Templates: Object factory system
             * 
             * Provides consistent patterns for creating application objects
             * like nodes and edges.
             * 
             * @version 1.üå≥1.0 - Enhanced with color support for nodes
             */
            const Templates = {
                /**
                 * Creates a new node with specified properties
                 * @param {Object} props - Properties to override defaults
                 * @returns {Object} A new node object
                 */
                createNode: function(props = {}) {
                    const id = props.id || `node-${State.counters.nextNodeId++}`;
                    
                    return {
                        id: id,
                        emoji: props.emoji || META.node.defaults.emoji,
                        name: props.name || '',
                        content: props.content || META.node.defaults.content,
                        color: props.color || META.node.defaults.color,
                        x: props.x || 0,
                        y: props.y || 0,
                        size: props.size || META.node.defaults.size
                    };
                },
                
                /**
                 * Creates a new edge between two nodes
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} A new edge object
                 */
                createEdge: function(sourceId, targetId) {
                    return {
                        id: `edge-${State.counters.nextEdgeId++}`,
                        sourceId: sourceId,
                        targetId: targetId
                    };
                }
            };
            
            // =====================================================================
            // STATE: Global Application State
            // =====================================================================

            /**
             * State: Global application state management
             * 
             * Centralizes all application data and state management functions.
             * 
             * @version 1.üå≥1.0 - Enhanced with independent display controls, node removal, and import/export
             */
            const State = {
                /** Graph data containing nodes and edges */
                graph: {
                    nodes: [],
                    edges: []
                },
                
                /** UI state information */
                ui: {
                    selectedNode: null,
                    isDragging: false,
                    draggedNode: null,
                    dragStartX: 0,
                    dragStartY: 0,
                    dragOffsetX: 0,
                    dragOffsetY: 0,
                    hoveredNode: null,
                    
                    // New display state with independent controls
                    display: {
                        showEmoji: META.node.display.emojiVisible,
                        showTitle: META.node.display.titleVisible,
                        isTransitioning: false,
                        transitionStartTime: 0,
                        animationId: null
                    }
                },
                
                /** Global counters */
                counters: {
                    nextNodeId: 1,
                    nextEdgeId: 1
                },
                
                /**
                 * Selects a node and updates UI accordingly
                 * @param {Object|null} node - Node to select or null to deselect
                 */
                selectNode: function(node) {
                    this.ui.selectedNode = node;
                    UI.updateEditor(node);
                    Renderer.draw();
                    
                    if (node) {
                        UI.updateStatus(META.templates.status.selected(node.name || 'Untitled Node'));
                    } else {
                        UI.updateStatus(META.templates.status.ready);
                    }
                },
                
                /**
                 * Adds a new node to the graph
                 * @param {Object} nodeProps - Properties for the new node
                 * @returns {Object} The created node
                 */
                addNode: function(nodeProps) {
                    const node = Templates.createNode(nodeProps);
                    this.graph.nodes.push(node);
                    return node;
                },
                
                /**
                 * Removes a node and all its connected edges
                 * @param {string} nodeId - ID of node to remove
                 * @returns {boolean} Success status
                 */
                removeNode: function(nodeId) {
                    // Find the node
                    const nodeIndex = this.graph.nodes.findIndex(n => n.id === nodeId);
                    if (nodeIndex === -1) return false;
                    
                    // Get node name for status update
                    const nodeName = this.graph.nodes[nodeIndex].name || 'Untitled Node';
                    
                    // Remove all connected edges
                    this.graph.edges = this.graph.edges.filter(edge => 
                        edge.sourceId !== nodeId && edge.targetId !== nodeId
                    );
                    
                    // Remove the node
                    this.graph.nodes.splice(nodeIndex, 1);
                    
                    // Update selection if removed node was selected
                    if (this.ui.selectedNode && this.ui.selectedNode.id === nodeId) {
                        this.selectNode(null);
                    }
                    
                    // Update display
                    Renderer.draw();
                    
                    // Update status
                    UI.updateStatus(META.templates.status.removed(nodeName));
                    
                    return true;
                },
                
                /**
                 * Connects two nodes with an edge
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} The created edge
                 */
                addEdge: function(sourceId, targetId) {
                    const edge = Templates.createEdge(sourceId, targetId);
                    this.graph.edges.push(edge);
                    return edge;
                },
                
                /**
                 * Finds a node at the specified coordinates
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @returns {Object|null} Node at coordinates or null if none found
                 */
                findNodeAt: function(x, y) {
                    // Search from front to back (later nodes appear on top)
                    for (let i = this.graph.nodes.length - 1; i >= 0; i--) {
                        const node = this.graph.nodes[i];
                        
                        // Calculate node dimensions based on display mode
                        const dimensions = this.calculateNodeDimensions(node);
                        
                        // Simple rectangle collision check
                        if (x >= dimensions.left && x <= dimensions.right && 
                            y >= dimensions.top && y <= dimensions.bottom) {
                            // Additional check for rounded corners
                            const radius = dimensions.height / 2;
                            
                            // Check if in corner regions
                            if (dimensions.isRounded) {
                                // Check corners for rectangular nodes
                                if (x < dimensions.left + radius && y < dimensions.top + radius) {
                                    // Top-left corner
                                    const cornerX = dimensions.left + radius;
                                    const cornerY = dimensions.top + radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                                else if (x > dimensions.right - radius && y < dimensions.top + radius) {
                                    // Top-right corner
                                    const cornerX = dimensions.right - radius;
                                    const cornerY = dimensions.top + radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                                else if (x < dimensions.left + radius && y > dimensions.bottom - radius) {
                                    // Bottom-left corner
                                    const cornerX = dimensions.left + radius;
                                    const cornerY = dimensions.bottom - radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                                else if (x > dimensions.right - radius && y > dimensions.bottom - radius) {
                                    // Bottom-right corner
                                    const cornerX = dimensions.right - radius;
                                    const cornerY = dimensions.bottom - radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                            } else if (dimensions.isCircular) {
                                // Calculate distance from center for circular nodes
                                const centerX = (dimensions.left + dimensions.right) / 2;
                                const centerY = (dimensions.top + dimensions.bottom) / 2;
                                const dx = x - centerX;
                                const dy = y - centerY;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance > radius) continue;
                            }
                            
                            return node;
                        }
                    }
                    return null;
                },
                
                /**
                 * Calculate node dimensions based on display mode
                 * @param {Object} node - Node to calculate dimensions for
                 * @returns {Object} Node dimension information including bounds and shape
                 */
                calculateNodeDimensions: function(node) {
                    const centerX = node.x + node.size / 2;
                    const centerY = node.y + node.size / 2;
                    
                    // Calculate based on current display mode
                    const showEmoji = this.ui.display.showEmoji;
                    const showTitle = this.ui.display.showTitle;
                    
                    // Both emoji and title
                    if (showEmoji && showTitle) {
                        // Measure text
                        const canvas = DOM.canvas;
                        const ctx = DOM.ctx;
                        const fontSize = node.size * META.node.display.title.fontSize;
                        ctx.font = `${fontSize}px ${window.getComputedStyle(document.body).fontFamily}`;
                        const textWidth = ctx.measureText(node.name || 'Untitled').width;
                        
                        // Calculate dimensions
                        const padding = node.size * META.node.display.title.padding;
                        const minWidth = node.size;
                        const width = Math.max(minWidth, textWidth + padding * 2);
                        const height = node.size;
                        
                        // Calculate bounds
                        return {
                            left: centerX - width / 2,
                            right: centerX + width / 2,
                            top: centerY - height / 2,
                            bottom: centerY + height / 2,
                            width: width,
                            height: height,
                            isRounded: true,
                            isCircular: false
                        };
                    } 
                    // Only emoji
                    else if (showEmoji && !showTitle) {
                        // Circular node
                        const radius = node.size / 2;
                        return {
                            left: centerX - radius,
                            right: centerX + radius,
                            top: centerY - radius,
                            bottom: centerY + radius,
                            width: node.size,
                            height: node.size,
                            isRounded: false,
                            isCircular: true
                        };
                    }
                    // Only title
                    else if (!showEmoji && showTitle) {
                        // Text-only node
                        const canvas = DOM.canvas;
                        const ctx = DOM.ctx;
                        const fontSize = node.size * META.node.display.title.fontSize;
                        ctx.font = `${fontSize}px ${window.getComputedStyle(document.body).fontFamily}`;
                        const textWidth = ctx.measureText(node.name || 'Untitled').width;
                        
                        // Calculate dimensions
                        const padding = node.size * META.node.display.title.padding;
                        const minWidth = node.size * 0.8; // Slightly smaller than emoji node
                        const width = Math.max(minWidth, textWidth + padding * 2);
                        const height = node.size * 0.7; // Smaller height for text-only
                        
                        // Calculate bounds
                        return {
                            left: centerX - width / 2,
                            right: centerX + width / 2,
                            top: centerY - height / 2,
                            bottom: centerY + height / 2,
                            width: width,
                            height: height,
                            isRounded: true,
                            isCircular: false
                        };
                    }
                    // Default: minimal node (fallback if both disabled)
                    else {
                        // Small dot node
                        const smallRadius = node.size / 3;
                        return {
                            left: centerX - smallRadius,
                            right: centerX + smallRadius,
                            top: centerY - smallRadius,
                            bottom: centerY + smallRadius,
                            width: smallRadius * 2,
                            height: smallRadius * 2,
                            isRounded: false,
                            isCircular: true
                        };
                    }
                },
                
                /**
                 * Updates node properties
                 * @param {string} nodeId - ID of node to update
                 * @param {Object} changes - Properties to update
                 */
                updateNode: function(nodeId, changes) {
                    const node = this.graph.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    // Apply changes
                    Object.assign(node, changes);
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.updated(node.name || 'Untitled Node'));
                },
                
                /**
                 * Toggles emoji display
                 * @param {boolean} visible - Whether emoji should be visible
                 */
                toggleEmojiDisplay: function(visible) {
                    if (this.ui.display.showEmoji === visible) return;
                    
                    this.ui.display.showEmoji = visible;
                    
                    // Check that at least one display mode is enabled
                    if (!this.ui.display.showEmoji && !this.ui.display.showTitle) {
                        // Enable title mode if trying to hide both
                        this.ui.display.showTitle = true;
                        UI.updateDisplayToggles();
                    }
                    
                    // Start transition animation
                    this.startDisplayTransition();
                    
                    UI.updateStatus(META.templates.status.displayChanged('emoji: ' + visible));
                },
                
                /**
                 * Toggles title display
                 * @param {boolean} visible - Whether titles should be visible
                 */
                toggleTitleDisplay: function(visible) {
                    if (this.ui.display.showTitle === visible) return;
                    
                    this.ui.display.showTitle = visible;
                    
                    // Check that at least one display mode is enabled
                    if (!this.ui.display.showEmoji && !this.ui.display.showTitle) {
                        // Enable emoji mode if trying to hide both
                        this.ui.display.showEmoji = true;
                        UI.updateDisplayToggles();
                    }
                    
                    // Start transition animation
                    this.startDisplayTransition();
                    
                    UI.updateStatus(META.templates.status.displayChanged('title: ' + visible));
                },
                
                /**
                 * Starts display transition animation
                 */
                startDisplayTransition: function() {
                    // Set up animation state
                    this.ui.display.isTransitioning = true;
                    this.ui.display.transitionStartTime = performance.now();
                    
                    // Start animation if not already running
                    if (!this.ui.display.animationId) {
                        this.ui.display.animationId = requestAnimationFrame(() => this.animateDisplayTransition());
                    }
                },
                
                /**
                 * Animate transition between display modes
                 */
                animateDisplayTransition: function() {
                    const now = performance.now();
                    const elapsed = now - this.ui.display.transitionStartTime;
                    const progress = Math.min(elapsed / META.animation.duration, 1);
                    
                    // Use easing function for smoother animation
                    const easedProgress = this.easeInOutCubic(progress);
                    
                    // Draw current frame with transition progress
                    Renderer.draw(easedProgress);
                    
                    if (progress < 1) {
                        // Continue animation
                        this.ui.display.animationId = requestAnimationFrame(() => this.animateDisplayTransition());
                    } else {
                        // End transition
                        this.ui.display.isTransitioning = false;
                        this.ui.display.animationId = null;
                        Renderer.draw(); // Final frame
                    }
                },
                
                /**
                 * Easing function for smooth transitions
                 * @param {number} t - Progress from 0 to 1
                 * @returns {number} Eased value
                 */
                easeInOutCubic: function(t) {
                    return t < 0.5
                        ? 4 * t * t * t
                        : 1 - Math.pow(-2 * t + 2, 3) / 2;
                },
                
                /**
                 * Exports graph data to JSON
                 */
                exportData: function() {
                    TransferManager.exportJson();
                },
                
                /**
                 * Imports graph data from JSON
                 * @param {File} file - JSON file to import
                 */
                importData: function(file) {
                    TransferManager.importJson(file);
                },
                
                /**
                 * Resets the application state
                 * @param {Object} newData - Optional new data to initialize with
                 */
                reset: function(newData = null) {
                    // Clear current state
                    this.graph.nodes = [];
                    this.graph.edges = [];
                    this.selectNode(null);
                    
                    // Initialize with new data if provided
                    if (newData) {
                        // Reset counters
                        if (newData.nodes && newData.nodes.length > 0) {
                            // Find highest ID numbers and set counters accordingly
                            const nodeIds = newData.nodes
                                .map(n => parseInt(n.id.replace('node-', '')))
                                .filter(id => !isNaN(id));
                            
                            if (nodeIds.length > 0) {
                                this.counters.nextNodeId = Math.max(...nodeIds) + 1;
                            }
                        }
                        
                        if (newData.edges && newData.edges.length > 0) {
                            const edgeIds = newData.edges
                                .map(e => parseInt(e.id.replace('edge-', '')))
                                .filter(id => !isNaN(id));
                            
                            if (edgeIds.length > 0) {
                                this.counters.nextEdgeId = Math.max(...edgeIds) + 1;
                            }
                        }
                        
                        // Copy nodes and edges
                        if (newData.nodes) {
                            // Ensure all nodes have required properties
                            this.graph.nodes = newData.nodes.map(node => {
                                // Apply defaults for missing properties
                                return {
                                    id: node.id,
                                    emoji: node.emoji || META.node.defaults.emoji,
                                    name: node.name || '',
                                    content: node.content || '',
                                    color: node.color || META.node.defaults.color,
                                    x: node.x || 0,
                                    y: node.y || 0,
                                    size: node.size || META.node.defaults.size
                                };
                            });
                        }
                        
                        if (newData.edges) {
                            this.graph.edges = [...newData.edges];
                        }
                    }
                    
                    // Redraw
                    Renderer.draw();
                }
            };
            
            // =====================================================================
            // DOM: Interface to DOM Elements
            // =====================================================================

            /**
             * DOM: Centralized DOM access
             * 
             * Provides a single interface to all DOM elements used by the application.
             * 
             * @version 1.üå≥1.0 - Enhanced with color picker and display toggles
             */
            const DOM = {
                /** Element references */
                elements: {},
                
                /** Canvas element and context */
                canvas: null,
                ctx: null,
                
                /**
                 * Initializes DOM references
                 * Gathers all necessary DOM elements into a single access point
                 */
                init: function() {
                    // Core elements
                    const ids = [
                        'network-canvas', 'add-node-btn', 'export-json-btn', 'import-json-btn',
                        'node-name', 'node-content', 'update-node-btn', 'remove-node-btn', 'editor-title',
                        'editor-subtitle', 'editor-placeholder', 'status', 'node-tooltip',
                        'node-emoji-select', 'emoji-picker', 'emoji-grid', 'emoji-toggle', 'title-toggle',
                        'node-color-select', 'color-picker', 'color-grid', 'custom-color',
                        'import-file', 'remove-confirmation-modal', 'cancel-remove-btn', 'confirm-remove-btn'
                    ];
                    
                    // Populate elements object
                    ids.forEach(id => {
                        this.elements[id] = document.getElementById(id);
                    });
                    
                    // Setup canvas and context
                    this.canvas = this.elements['network-canvas'];
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Ensure canvas is properly sized
                    this.resizeCanvas();
                    
                    // Initialize pickers
                    this.initEmojiPicker();
                    this.initColorPicker();
                },
                
                /**
                 * Sets the canvas size to match its container
                 */
                resizeCanvas: function() {
                    const container = document.querySelector('.canvas-container');
                    this.canvas.width = container.offsetWidth;
                    this.canvas.height = container.offsetHeight;
                },
                
                /**
                 * Initialize emoji picker with available options
                 */
                initEmojiPicker: function() {
                    const grid = this.elements['emoji-grid'];
                    const picker = this.elements['emoji-picker'];
                    if (!grid || !picker) return;
                    
                    // Clear existing items
                    grid.innerHTML = '';
                    
                    // Add all emojis
                    META.emojiPicker.emojis.forEach(emoji => {
                        const item = document.createElement('div');
                        item.className = 'emoji-item';
                        item.textContent = emoji;
                        item.setAttribute('data-emoji', emoji);
                        item.addEventListener('click', () => {
                            if (State.ui.selectedNode) {
                                // Update the emoji select button
                                this.elements['node-emoji-select'].textContent = emoji;
                                
                                // Hide the picker
                                picker.classList.remove('active');
                            }
                        });
                        
                        grid.appendChild(item);
                    });
                    
                    // Calculate and set picker width dynamically
                    const columns = META.emojiPicker.columns;
                    const itemSize = META.emojiPicker.itemSize;
                    const gapSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--space-sm'));
                    const paddingSize = META.emojiPicker.padding * 2;
                    
                    // Width = (columns * itemSize) + (gaps between items) + (padding on both sides)
                    const totalWidth = (columns * itemSize) + ((columns - 1) * gapSize) + paddingSize;
                    picker.style.width = `${totalWidth}px`;
                    
                    // Set up emoji select button
                    const emojiSelect = this.elements['node-emoji-select'];
                    
                    if (emojiSelect && picker) {
                        emojiSelect.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // Position the picker near the button
                            const rect = emojiSelect.getBoundingClientRect();
                            picker.style.top = `${rect.bottom + 5}px`;
                            picker.style.left = `${rect.left}px`;
                            
                            // Toggle visibility
                            picker.classList.toggle('active');
                            
                            // Hide color picker if open
                            const colorPicker = this.elements['color-picker'];
                            if (colorPicker) {
                                colorPicker.classList.remove('active');
                            }
                        });
                    }
                },
                
                /**
                 * Initialize color picker with palette and custom color option
                 */
                initColorPicker: function() {
                    const grid = this.elements['color-grid'];
                    const picker = this.elements['color-picker'];
                    const customColor = this.elements['custom-color'];
                    
                    if (!grid || !picker) return;
                    
                    // Clear existing items
                    grid.innerHTML = '';
                    
                    // Add color palette
                    META.node.colors.forEach(color => {
                        const item = document.createElement('div');
                        item.className = 'color-item';
                        item.style.backgroundColor = color;
                        item.setAttribute('data-color', color);
                        item.addEventListener('click', () => {
                            if (State.ui.selectedNode) {
                                // Update the color select button
                                this.elements['node-color-select'].style.backgroundColor = color;
                                
                                // Update custom color input
                                if (customColor) {
                                    customColor.value = color;
                                }
                                
                                // Hide the picker
                                picker.classList.remove('active');
                            }
                        });
                        
                        grid.appendChild(item);
                    });
                    
                    // Set up custom color input
                    if (customColor) {
                        customColor.addEventListener('input', (e) => {
                            // Update color select when custom color changes
                            const color = e.target.value;
                            this.elements['node-color-select'].style.backgroundColor = color;
                        });
                    }
                    
                    // Set up color select button
                    const colorSelect = this.elements['node-color-select'];
                    
                    if (colorSelect && picker) {
                        colorSelect.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // Position the picker near the button
                            const rect = colorSelect.getBoundingClientRect();
                            picker.style.top = `${rect.bottom + 5}px`;
                            picker.style.left = `${rect.left}px`;
                            
                            // Toggle visibility
                            picker.classList.toggle('active');
                            
                            // Hide emoji picker if open
                            const emojiPicker = this.elements['emoji-picker'];
                            if (emojiPicker) {
                                emojiPicker.classList.remove('active');
                            }
                        });
                    }
                },
                
                /**
                 * Check if an emoji is supported in the current browser
                 * @param {string} emoji - Emoji character to check
                 * @returns {boolean} True if emoji is likely supported
                 */
                isEmojiSupported: function(emoji) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Use a large enough font size
                    ctx.font = '20px sans-serif';
                    
                    // Try to draw the emoji
                    ctx.fillText(emoji, 0, 0);
                    
                    // Check if pixel data is not empty
                    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    
                    // Check if any pixel has alpha > 0
                    for (let i = 3; i < data.length; i += 4) {
                        if (data[i] > 0) return true;
                    }
                    
                    return false;
                },
                
                /**
                 * Show a confirmation modal
                 * @param {string} modalId - ID of modal to show
                 */
                showModal: function(modalId) {
                    const modal = this.elements[modalId];
                    if (modal) {
                        modal.classList.add('active');
                    }
                },
                
                /**
                 * Hide a confirmation modal
                 * @param {string} modalId - ID of modal to hide
                 */
                hideModal: function(modalId) {
                    const modal = this.elements[modalId];
                    if (modal) {
                        modal.classList.remove('active');
                    }
                }
            };
            
            // =====================================================================
            // UI: User Interface Management
            // =====================================================================

            /**
             * UI: User interface controller
             * 
             * Handles all updates to the user interface based on application state.
             * 
             * @version 1.üå≥1.0 - Enhanced with color selection and display toggles
             */
            const UI = {
                /**
                 * Updates the node editor with node content
                 * @param {Object|null} node - Node to edit or null to clear editor
                 */
                updateEditor: function(node) {
                    const placeholderEl = DOM.elements['editor-placeholder'];
                    const emojiSelectEl = DOM.elements['node-emoji-select'];
                    const colorSelectEl = DOM.elements['node-color-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    const titleEl = DOM.elements['editor-title'];
                    const subtitleEl = DOM.elements['editor-subtitle'];
                    const updateBtnEl = DOM.elements['update-node-btn'];
                    const removeBtnEl = DOM.elements['remove-node-btn'];
                    const emojiPickerEl = DOM.elements['emoji-picker'];
                    const colorPickerEl = DOM.elements['color-picker'];
                    
                    // Hide pickers if open
                    if (emojiPickerEl) {
                        emojiPickerEl.classList.remove('active');
                    }
                    if (colorPickerEl) {
                        colorPickerEl.classList.remove('active');
                    }
                    
                    if (node) {
                        // Show editor with node content
                        placeholderEl.style.display = 'none';
                        nameEl.style.display = 'block';
                        contentEl.style.display = 'block';
                        updateBtnEl.style.display = 'block';
                        removeBtnEl.style.display = 'block';
                        emojiSelectEl.parentElement.parentElement.style.display = 'flex';
                        
                        // Set content
                        emojiSelectEl.textContent = node.emoji;
                        colorSelectEl.style.backgroundColor = node.color || META.node.defaults.color;
                        nameEl.value = node.name || '';
                        contentEl.value = node.content || '';
                        
                        // Update custom color input if it exists
                        const customColorEl = DOM.elements['custom-color'];
                        if (customColorEl) {
                            customColorEl.value = node.color || META.node.defaults.color;
                        }
                        
                        // Update headings
                        titleEl.innerHTML = `<span class="node-emoji">${node.emoji}</span> Editing ${node.name || 'Untitled Node'}`;
                        subtitleEl.textContent = 'Make changes and click "Update Node" to save';
                    } else {
                        // Hide editor, show placeholder
                        placeholderEl.style.display = 'flex';
                        nameEl.style.display = 'none';
                        contentEl.style.display = 'none';
                        updateBtnEl.style.display = 'none';
                        removeBtnEl.style.display = 'none';
                        emojiSelectEl.parentElement.parentElement.style.display = 'none';
                        
                        // Update headings
                        titleEl.textContent = 'Node Editor';
                        subtitleEl.textContent = 'Select a node to edit its content';
                    }
                },
                
                /**
                 * Update display toggle switches to match current state
                 */
                updateDisplayToggles: function() {
                    const emojiToggle = DOM.elements['emoji-toggle'];
                    const titleToggle = DOM.elements['title-toggle'];
                    
                    if (emojiToggle) {
                        emojiToggle.checked = State.ui.display.showEmoji;
                    }
                    
                    if (titleToggle) {
                        titleToggle.checked = State.ui.display.showTitle;
                    }
                },
                
                /**
                 * Show node tooltip at specified position
                 * @param {Object} node - Node to show tooltip for
                 * @param {number} x - X position
                 * @param {number} y - Y position 
                 */
                showNodeTooltip: function(node, x, y) {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    // Set tooltip content (adaptive based on what's already visible)
                    let content = '';
                    
                    if (State.ui.display.showEmoji && State.ui.display.showTitle) {
                        // Both visible, show content preview
                        content = node.content ? node.content.substring(0, 30) + (node.content.length > 30 ? '...' : '') : 'No content';
                    } else if (State.ui.display.showEmoji && !State.ui.display.showTitle) {
                        // Only emoji visible, show name
                        content = node.name || 'Untitled Node';
                    } else if (!State.ui.display.showEmoji && State.ui.display.showTitle) {
                        // Only title visible, show emoji
                        content = node.emoji;
                    } else {
                        // Neither visible (shouldn't happen), show both
                        content = `${node.emoji} ${node.name || 'Untitled Node'}`;
                    }
                    
                    // Set tooltip content and position
                    tooltip.textContent = content;
                    tooltip.style.left = `${x}px`;
                    tooltip.style.top = `${y - 30}px`;
                    tooltip.style.opacity = '1';
                    
                    // Update hovered node reference
                    State.ui.hoveredNode = node;
                },
                
                /**
                 * Hide node tooltip
                 */
                hideNodeTooltip: function() {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    tooltip.style.opacity = '0';
                    State.ui.hoveredNode = null;
                },
                
                /**
                 * Updates the status message
                 * @param {string} message - Status message to display
                 * @param {number} [duration=3000] - Duration to show message in ms
                 */
                updateStatus: function(message, duration = 3000) {
                    const statusEl = DOM.elements.status;
                    if (!statusEl) return;
                    
                    // Set message
                    statusEl.textContent = message;
                    Debug.log(`Status: ${message}`);
                    
                    // Clear after duration
                    setTimeout(() => {
                        if (statusEl.textContent === message) {
                            statusEl.textContent = State.ui.selectedNode ? 
                                META.templates.status.selected(State.ui.selectedNode.name || 'Untitled Node') : 
                                META.templates.status.ready;
                        }
                    }, duration);
                }
            };
            
            // =====================================================================
            // RENDERER: Canvas Drawing System
            // =====================================================================

            /**
             * Renderer: Visual drawing system
             * 
             * Handles all drawing operations on the canvas, visualizing
             * the nodes and edges in the network.
             * 
             * @version 1.üå≥1.0 - Enhanced with color support and display modes
             */
            const Renderer = {
                /**
                 * Draws the complete graph
                 * @param {number} [transitionProgress=null] - Optional transition progress (0-1)
                 */
                draw: function(transitionProgress = null) {
                    const ctx = DOM.ctx;
                    const canvas = DOM.canvas;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw all edges
                    this.drawEdges();
                    
                    // Draw all nodes
                    this.drawNodes(transitionProgress);
                },
                
                /**
                 * Draws all edges in the graph
                 */
                drawEdges: function() {
                    const ctx = DOM.ctx;
                    const edges = State.graph.edges;
                    
                    // Set default edge style
                    ctx.strokeStyle = META.edge.style.color;
                    ctx.lineWidth = META.edge.style.width;
                    
                    edges.forEach(edge => {
                        // Find connected nodes
                        const sourceNode = State.graph.nodes.find(n => n.id === edge.sourceId);
                        const targetNode = State.graph.nodes.find(n => n.id === edge.targetId);
                        
                        // Skip if either node is missing
                        if (!sourceNode || !targetNode) return;
                        
                        // Calculate connection points (center of nodes)
                        const sourceX = sourceNode.x + sourceNode.size / 2;
                        const sourceY = sourceNode.y + sourceNode.size / 2;
                        const targetX = targetNode.x + targetNode.size / 2;
                        const targetY = targetNode.y + targetNode.size / 2;
                        
                        // Draw connecting line
                        ctx.beginPath();
                        ctx.moveTo(sourceX, sourceY);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                    });
                },
                
                /**
                 * Draws all nodes in the graph
                 * @param {number} [transitionProgress=null] - Optional transition progress (0-1)
                 */
                drawNodes: function(transitionProgress = null) {
                    const nodes = State.graph.nodes;
                    
                    nodes.forEach(node => {
                        this.drawNode(node, transitionProgress);
                    });
                },
                
                /**
                 * Draws a single node
                 * @param {Object} node - Node to draw
                 * @param {number} [transitionProgress=null] - Optional transition progress (0-1)
                 */
                drawNode: function(node, transitionProgress = null) {
                    const ctx = DOM.ctx;
                    const isSelected = node === State.ui.selectedNode;
                    
                    // Calculate center position
                    const centerX = node.x + node.size / 2;
                    const centerY = node.y + node.size / 2;
                    
                    // Get current display mode
                    const showEmoji = State.ui.display.showEmoji;
                    const showTitle = State.ui.display.showTitle;
                    
                    // Check if we're in transition
                    const isTransitioning = State.ui.display.isTransitioning && transitionProgress !== null;
                    
                    if (isTransitioning) {
                        // Draw transition between display modes
                        this.drawNodeTransition(node, centerX, centerY, isSelected, transitionProgress);
                    } else {
                        // Draw based on current display mode
                        if (showEmoji && showTitle) {
                            // Both emoji and title
                            this.drawTitleNode(node, centerX, centerY, isSelected, true);
                        } else if (showEmoji && !showTitle) {
                            // Only emoji
                            this.drawEmojiNode(node, centerX, centerY, isSelected);
                        } else if (!showEmoji && showTitle) {
                            // Only title
                            this.drawTitleNode(node, centerX, centerY, isSelected, false);
                        } else {
                            // Fallback: minimal node (shouldn't happen in normal use)
                            this.drawMinimalNode(node, centerX, centerY, isSelected);
                        }
                    }
                },
                
                /**
                 * Draws node with emoji
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 */
                drawEmojiNode: function(node, centerX, centerY, isSelected) {
                    const ctx = DOM.ctx;
                    const radius = node.size / 2;
                    
                    // Draw node background circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    // Fill with node color
                    ctx.fillStyle = node.color || META.node.defaults.color;
                    ctx.fill();
                    
                    // Draw outline, thicker if selected
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#d9d9d9';
                        ctx.lineWidth = 1;
                    }
                    
                    ctx.stroke();
                    
                    // Draw emoji in center
                    const emojiSize = node.size * META.node.display.emoji.size;
                    ctx.font = `${emojiSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#333';
                    ctx.fillText(node.emoji, centerX, centerY);
                },
                
                /**
                 * Draws node with title (and optionally emoji)
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 * @param {boolean} showEmoji - Whether to include emoji
                 */
                drawTitleNode: function(node, centerX, centerY, isSelected, showEmoji) {
                    const ctx = DOM.ctx;
                    
                    // Calculate dimensions
                    const height = showEmoji ? node.size : node.size * 0.7;
                    const radius = height / 2;
                    
                    // Measure text
                    const fontSize = node.size * META.node.display.title.fontSize;
                    ctx.font = `${fontSize}px ${window.getComputedStyle(document.body).fontFamily}`;
                    const title = node.name || 'Untitled';
                    const textMetrics = ctx.measureText(title);
                    const textWidth = textMetrics.width;
                    
                    // Calculate width (minimum is the node size)
                    const padding = node.size * META.node.display.title.padding;
                    const minWidth = showEmoji ? node.size : node.size * 0.8;
                    const width = Math.max(minWidth, textWidth + padding * 2);
                    
                    // Calculate top-left corner position
                    const x = centerX - width / 2;
                    const y = centerY - height / 2;
                    
                    // Draw rounded rectangle
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.arcTo(x + width, y, x + width, y + radius, radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
                    ctx.lineTo(x + radius, y + height);
                    ctx.arcTo(x, y + height, x, y + height - radius, radius);
                    ctx.lineTo(x, y + radius);
                    ctx.arcTo(x, y, x + radius, y, radius);
                    ctx.closePath();
                    
                    // Fill with node color
                    ctx.fillStyle = node.color || META.node.defaults.color;
                    ctx.fill();
                    
                    // Draw outline
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#d9d9d9';
                        ctx.lineWidth = 1;
                    }
                    ctx.stroke();
                    
                    // Draw title text
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(title, centerX, centerY);
                    
                    // Draw emoji if showing both
                    if (showEmoji) {
                        // Draw small emoji indicator in top left
                        const emojiSize = node.size * 0.2;
                        ctx.font = `${emojiSize}px Arial`;
                        ctx.fillText(node.emoji, x + emojiSize, y + emojiSize);
                    }
                },
                
                /**
                 * Draws a minimal node (fallback for when neither emoji nor title is shown)
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 */
                drawMinimalNode: function(node, centerX, centerY, isSelected) {
                    const ctx = DOM.ctx;
                    const radius = node.size / 3; // Smaller than regular nodes
                    
                    // Draw node background circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    // Fill with node color or darker version to make it visible
                    ctx.fillStyle = node.color || '#bbdefb'; // Make default more visible
                    ctx.fill();
                    
                    // Draw outline, thicker if selected
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#777777'; // Darker for visibility
                        ctx.lineWidth = 1.5;
                    }
                    
                    ctx.stroke();
                },
                
                /**
                 * Draws node transitioning between display modes
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 * @param {number} progress - Transition progress (0-1)
                 */
                drawNodeTransition: function(node, centerX, centerY, isSelected, progress) {
                    const ctx = DOM.ctx;
                    
                    // Get current display state
                    const showEmoji = State.ui.display.showEmoji;
                    const showTitle = State.ui.display.showTitle;
                    
                    // Determine transition type based on current state
                    if (showEmoji && showTitle) {
                        // Transitioning to showing both
                        // Draw title node with fading in emoji
                        ctx.globalAlpha = progress;
                        this.drawTitleNode(node, centerX, centerY, isSelected, true);
                        ctx.globalAlpha = 1;
                        
                        // Draw fading emoji node
                        ctx.globalAlpha = 1 - progress;
                        if (!showTitle) {
                            // Coming from emoji-only
                            this.drawEmojiNode(node, centerX, centerY, isSelected);
                        } else {
                            // Coming from title-only
                            this.drawTitleNode(node, centerX, centerY, isSelected, false);
                        }
                        ctx.globalAlpha = 1;
                    } else if (showEmoji && !showTitle) {
                        // Transitioning to emoji-only
                        ctx.globalAlpha = progress;
                        this.drawEmojiNode(node, centerX, centerY, isSelected);
                        ctx.globalAlpha = 1;
                        
                        // Fade out previous mode
                        ctx.globalAlpha = 1 - progress;
                        this.drawTitleNode(node, centerX, centerY, isSelected, !showEmoji);
                        ctx.globalAlpha = 1;
                    } else if (!showEmoji && showTitle) {
                        // Transitioning to title-only
                        ctx.globalAlpha = progress;
                        this.drawTitleNode(node, centerX, centerY, isSelected, false);
                        ctx.globalAlpha = 1;
                        
                        // Fade out previous mode
                        ctx.globalAlpha = 1 - progress;
                        this.drawEmojiNode(node, centerX, centerY, isSelected);
                        ctx.globalAlpha = 1;
                    } else {
                        // This shouldn't happen in normal operation
                        this.drawMinimalNode(node, centerX, centerY, isSelected);
                    }
                }
            };
            
            // =====================================================================
            // INPUT: User Interaction Handler
            // =====================================================================

            /**
             * InputHandler: Interaction management
             * 
             * Handles all user interactions with the application,
             * including mouse events, keyboard input, and button clicks.
             * 
             * @version 1.üå≥1.0 - Enhanced with display toggles, node removal, and import/export
             */
            const InputHandler = {
                /**
                 * Sets up all event listeners
                 */
                init: function() {
                    // Canvas mouse events
                    DOM.canvas.addEventListener('mousedown', this.handleMouseDown);
                    DOM.canvas.addEventListener('mousemove', this.handleMouseMove);
                    DOM.canvas.addEventListener('mouseup', this.handleMouseUp);
                    DOM.canvas.addEventListener('click', this.handleClick);
                    
                    // Button events
                    DOM.elements['add-node-btn'].addEventListener('click', this.handleAddNode);
                    DOM.elements['update-node-btn'].addEventListener('click', this.handleUpdateNode);
                    DOM.elements['remove-node-btn'].addEventListener('click', this.handleRemoveNodePrompt);
                    DOM.elements['export-json-btn'].addEventListener('click', () => State.exportData());
                    DOM.elements['import-json-btn'].addEventListener('click', this.handleImportButtonClick);
                    
                    // File import handling
                    DOM.elements['import-file'].addEventListener('change', this.handleFileImport);
                    
                    // Display toggle events
                    DOM.elements['emoji-toggle'].addEventListener('change', (e) => {
                        State.toggleEmojiDisplay(e.target.checked);
                    });
                    
                    DOM.elements['title-toggle'].addEventListener('change', (e) => {
                        State.toggleTitleDisplay(e.target.checked);
                    });
                    
                    // Removal confirmation modal events
                    DOM.elements['cancel-remove-btn'].addEventListener('click', () => {
                        DOM.hideModal('remove-confirmation-modal');
                    });
                    
                    DOM.elements['confirm-remove-btn'].addEventListener('click', this.handleRemoveNode);
                    
                    // Document-level click handler to close pickers
                    document.addEventListener('click', (e) => {
                        // Close pickers when clicking outside
                        const emojiPicker = DOM.elements['emoji-picker'];
                        const colorPicker = DOM.elements['color-picker'];
                        const emojiButton = DOM.elements['node-emoji-select'];
                        const colorButton = DOM.elements['node-color-select'];
                        
                        if (emojiPicker && e.target !== emojiButton && !emojiPicker.contains(e.target)) {
                            emojiPicker.classList.remove('active');
                        }
                        
                        if (colorPicker && e.target !== colorButton && !colorPicker.contains(e.target)) {
                            colorPicker.classList.remove('active');
                        }
                    });
                    
                    // Window resize event
                    window.addEventListener('resize', () => {
                        DOM.resizeCanvas();
                        Renderer.draw();
                    });
                },
                
                /**
                 * Handles mouse down event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseDown: function(e) {
                    // Get mouse position relative to canvas
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find node under cursor
                    const node = State.findNodeAt(x, y);
                    
                    if (node) {
                        // Set drag start position
                        State.ui.dragStartX = x;
                        State.ui.dragStartY = y;
                        State.ui.draggedNode = node;
                        
                        // Calculate offset from the top-left corner of the node
                        State.ui.dragOffsetX = x - node.x;
                        State.ui.dragOffsetY = y - node.y;
                        
                        // Don't set isDragging yet - wait for movement threshold
                        
                        // Change cursor
                        DOM.canvas.style.cursor = 'grabbing';
                    }
                },
                
                /**
                 * Handles mouse move event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseMove: function(e) {
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Handle dragging - wait for movement threshold
                    if (State.ui.draggedNode) {
                        // Check if we've moved enough to start dragging
                        const dragDistance = Math.sqrt(
                            Math.pow(x - State.ui.dragStartX, 2) + 
                            Math.pow(y - State.ui.dragStartY, 2)
                        );
                        
                        if (dragDistance >= META.node.dragThreshold || State.ui.isDragging) {
                            // Start dragging if we haven't already
                            State.ui.isDragging = true;
                            
                            // Update node position
                            State.ui.draggedNode.x = x - State.ui.dragOffsetX;
                            State.ui.draggedNode.y = y - State.ui.dragOffsetY;
                            Renderer.draw();
                        }
                    } else {
                        // Check for node hovering for tooltip
                        const hoveredNode = State.findNodeAt(x, y);
                        
                        if (hoveredNode) {
                            // Show tooltip
                            UI.showNodeTooltip(hoveredNode, x, y);
                            // Update cursor
                            DOM.canvas.style.cursor = 'grab';
                        } else {
                            // Hide tooltip
                            UI.hideNodeTooltip();
                            // Reset cursor
                            DOM.canvas.style.cursor = 'default';
                        }
                    }
                },
                
                /**
                 * Handles mouse up event
                 */
                handleMouseUp: function() {
                    // End dragging
                    State.ui.isDragging = false;
                    State.ui.draggedNode = null;
                    
                    // Reset cursor
                    DOM.canvas.style.cursor = 'default';
                },
                
                /**
                 * Handles mouse click event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleClick: function(e) {
                    // Ignore if we were dragging
                    if (State.ui.isDragging) return;
                    
                    // Get mouse position
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find and select node
                    const node = State.findNodeAt(x, y);
                    State.selectNode(node);
                },
                
                /**
                 * Handles adding a new node
                 */
                handleAddNode: function() {
                    // Calculate position for new node
                    const canvas = DOM.canvas;
                    const nodeSize = META.node.defaults.size;
                    const centerX = canvas.width / 2 - nodeSize / 2;
                    const centerY = canvas.height / 2 - nodeSize / 2;
                    
                    // Add offset if there's a selected node
                    let x = centerX;
                    let y = centerY;
                    
                    if (State.ui.selectedNode) {
                        // Smart positioning based on display mode
                        if (State.ui.display.showTitle) {
                            // Vertical positioning for title mode (below parent)
                            const verticalOffset = META.node.positioning.verticalOffset;
                            const dimensions = State.calculateNodeDimensions(State.ui.selectedNode);
                            
                            x = State.ui.selectedNode.x;
                            y = State.ui.selectedNode.y + dimensions.height + nodeSize * verticalOffset;
                        } else {
                            // Horizontal positioning for emoji mode (beside parent)
                            const horizontalOffset = META.node.positioning.horizontalOffset;
                            x = State.ui.selectedNode.x + nodeSize * horizontalOffset;
                            y = State.ui.selectedNode.y;
                        }
                        
                        // Create edge from selected to new node
                        const newNode = State.addNode({ x, y });
                        State.addEdge(State.ui.selectedNode.id, newNode.id);
                        State.selectNode(newNode);
                    } else {
                        // Create welcome node at center if no selection
                        const welcomeNode = State.addNode({ 
                            x, y, 
                            emoji: META.templates.welcome.emoji,
                            name: META.templates.welcome.name,
                            content: META.templates.welcome.content,
                            color: META.templates.welcome.color
                        });
                        State.selectNode(welcomeNode);
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.created(State.ui.selectedNode.name || 'Untitled Node'));
                },
                
                /**
                 * Handles updating a node
                 */
                handleUpdateNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get values from editor
                    const emojiEl = DOM.elements['node-emoji-select'];
                    const colorEl = DOM.elements['node-color-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    
                    // Update node
                    State.updateNode(State.ui.selectedNode.id, {
                        emoji: emojiEl.textContent,
                        color: colorEl.style.backgroundColor,
                        name: nameEl.value,
                        content: contentEl.value
                    });
                    
                    // Update editor title
                    const titleEl = DOM.elements['editor-title'];
                    titleEl.innerHTML = `<span class="node-emoji">${emojiEl.textContent}</span> Editing ${nameEl.value || 'Untitled Node'}`;
                },
                
                /**
                 * Shows node removal confirmation prompt
                 */
                handleRemoveNodePrompt: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Show confirmation modal
                    DOM.showModal('remove-confirmation-modal');
                },
                
                /**
                 * Handles removing a node after confirmation
                 */
                handleRemoveNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get node name for status update
                    const nodeName = State.ui.selectedNode.name || 'Untitled Node';
                    
                    // Remove the node
                    State.removeNode(State.ui.selectedNode.id);
                    
                    // Hide the confirmation modal
                    DOM.hideModal('remove-confirmation-modal');
                    
                    // Update status
                    UI.updateStatus(META.templates.status.removed(nodeName));
                },
                
                /**
                 * Handles clicking the import button
                 */
                handleImportButtonClick: function() {
                    // Trigger file input click
                    DOM.elements['import-file'].click();
                },
                
                /**
                 * Handles file import
                 * @param {Event} e - Change event
                 */
                handleFileImport: function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    // Check file type
                    if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                        UI.updateStatus('Error: Please select a JSON file', 5000);
                        return;
                    }
                    
                    // Import data from file
                    State.importData(file);
                    
                    // Reset file input
                    e.target.value = '';
                }
            };
            
            // =====================================================================
            // TRANSFER MANAGER: Import and Export Functionality
            // =====================================================================

            /**
             * TransferManager: Data import and export system
             * 
             * Handles transferring graph data in and out of the application.
             * 
             * @version 1.üå≥1.0 - Enhanced with JSON import functionality
             */
            const TransferManager = {
                /**
                 * Exports graph to JSON
                 */
                exportJson: function() {
                    // Create a copy of the graph data
                    const graphData = JSON.stringify(State.graph, null, 2);
                    
                    // Download as file
                    this.downloadFile(
                        graphData, 
                        META.dataTransfer.formats.json.filename, 
                        META.dataTransfer.formats.json.contentType
                    );
                    UI.updateStatus(META.templates.status.exported('JSON'));
                },
                
                /**
                 * Imports graph from JSON file
                 * @param {File} file - JSON file to import
                 */
                importJson: function(file) {
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        try {
                            // Parse JSON data
                            const jsonData = JSON.parse(e.target.result);
                            
                            // Validate data structure
                            if (!jsonData.nodes || !Array.isArray(jsonData.nodes) ||
                                !jsonData.edges || !Array.isArray(jsonData.edges)) {
                                throw new Error('Invalid JSON format: Missing nodes or edges arrays');
                            }
                            
                            // Reset application state with new data
                            State.reset(jsonData);
                            
                            // Update status
                            UI.updateStatus(META.templates.status.imported(`${jsonData.nodes.length} nodes, ${jsonData.edges.length} edges`));
                        } catch (error) {
                            Debug.error('Import error:', error);
                            UI.updateStatus(`Error: ${error.message}`, 5000);
                        }
                    };
                    
                    reader.onerror = function() {
                        UI.updateStatus('Error: Failed to read file', 5000);
                    };
                    
                    reader.readAsText(file);
                },
                
                /**
                 * Creates and triggers download for a file
                 * @param {string} content - File content
                 * @param {string} fileName - File name
                 * @param {string} contentType - File MIME type
                 */
                downloadFile: function(content, fileName, contentType) {
                    // Create blob and download link
                    const blob = new Blob([content], { type: contentType });
                    const url = URL.createObjectURL(blob);
                    
                    // Create and trigger download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    
                    // Cleanup
                    URL.revokeObjectURL(url);
                }
            };
            
            // =====================================================================
            // DEBUG: Debugging Utilities
            // =====================================================================

            /**
             * Debug: Debugging toolkit
             * 
             * Provides consistent debugging output and error handling.
             * 
             * @version 1.üå≥1.0 - Maintained from previous version
             */
            const Debug = {
                /**
                 * Logs a debug message
                 * @param {string} message - Message to log
                 * @param {string} [level='info'] - Log level
                 */
                log: function(message, level = 'info') {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels[level] || META.debug.levels.info;
                    console.log(`${emoji} ${prefix} v${META.version.number}: ${message}`);
                },
                
                /**
                 * Logs an error message
                 * @param {string} message - Error message
                 * @param {Error} [error] - Error object
                 */
                error: function(message, error) {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels.error;
                    console.error(`${emoji} ${prefix} v${META.version.number}: ${message}`, error || '');
                },
                
                /**
                 * Logs a success message
                 * @param {string} message - Success message
                 */
                success: function(message) {
                    this.log(message, 'success');
                }
            };
            
            // =====================================================================
            // APP: Application Initialization
            // =====================================================================

            /**
             * App: Main application controller
             * 
             * Handles the initialization and startup of the application.
             * 
             * @version 1.üå≥1.0 - Enhanced with independent display controls
             */
            const App = {
                /**
                 * Initializes the application
                 */
                init: function() {
                    // Initialize DOM references
                    DOM.init();
                    
                    // Set up event handlers
                    InputHandler.init();
                    
                    // Set display toggles to match state
                    UI.updateDisplayToggles();
                    
                    // Create initial node if no nodes exist
                    if (State.graph.nodes.length === 0) {
                        InputHandler.handleAddNode();
                    }
                    
                    // Check for emoji support
                    this.checkEmojiSupport();
                    
                    // Render initial state
                    Renderer.draw();
                    
                    Debug.success('Application initialized');
                    UI.updateStatus(`Welcome to NodePad v${META.version.number}!`);
                    
                    return this;
                },
                
                /**
                 * Check if emojis are supported in the current browser
                 * Falls back to simple symbols if needed
                 */
                checkEmojiSupport: function() {
                    // Test a few key emojis for support
                    const testEmojis = ['üå±', 'üåø', 'üå≥', 'üçÇ', 'üìù'];
                    let hasUnsupportedEmojis = false;
                    
                    // Simple feature detection for emoji support
                    testEmojis.forEach(emoji => {
                        if (!DOM.isEmojiSupported(emoji)) {
                            hasUnsupportedEmojis = true;
                            Debug.log(`Emoji not supported: ${emoji}`, 'warn');
                        }
                    });
                    
                    // If some emojis aren't supported, warn in debug
                    if (hasUnsupportedEmojis) {
                        Debug.log('Some emojis are not supported in this browser - consider using fallbacks', 'warn');
                    }
                }
            };
            
            // =====================================================================
            // Initialize the application when DOM is loaded
            // =====================================================================
            
            // Start the application
            App.init();
        });
    </script>
</body>
</html>