<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodePad v1.ü™¥1.0</title>
    <!-- 
        NodePad v1.ü™¥1.0: Visual Knowledge Network
        
        Version History:
        v0.0.1 - Initial implementation with popup editor and basic node display
        v0.0.2 - Attempted to refactor with Node class architecture (contained bugs)
        v0.0.3 - Fixed edge rendering bug and simplified architecture
        v0.0.4 - Restructured code with proper DocTrellis versioning and modularized components
        v0.0.5 - Fixed node interaction bug with dragging different nodes
        v0.0.6 - Implemented template-based node rendering system
        v0.0.7 - Added ability to edit node names
        v0.1.0 - First minor version with stable core features and cleaned documentation
        v1.0.0 - Complete constructivist rewrite with knot-compacted architecture
        v1.ü™¥1.0 - Simplified circular nodes with emoji identifiers and hover information
        
        DocTrellis Feature Status:
        ü™¥ Core Architecture - Potted Plant - Constructivist template system with metadata-driven design
        ü™¥ Node Management - Potted Plant - Create, select, edit, and drag nodes
        ü™¥ Edge Connections - Potted Plant - Connections between nodes
        ü™¥ Network View - Potted Plant - Canvas-based visualization with emoji identifiers
        üå± Export/Import - Seedling - JSON and CSV export functionality
        
        Leaf Pile (Pruned Ideas):
        üçÇ Source Explorer - Browser-based source code exploration using emoji markers
        üçÇ Custom node styles - Multiple visual presentation options for node content
    -->
    <style>
        /* Base Variables - Single Source of Truth */
        :root {
            /* Color Palette */
            --color-bg: #fafafa;
            --color-surface: #ffffff;
            --color-surface-alt: #f5f5f5;
            --color-border: #dddddd;
            --color-text: #333333;
            --color-text-muted: #666666;
            --color-primary: #1890ff;
            --color-primary-dark: #096dd9;
            --color-success: #52c41a;
            --color-warning: #faad14;
            --color-error: #f5222d;
            
            /* Spacing System */
            --space-unit: 8px;
            --space-xs: calc(var(--space-unit) * 0.5);  /* 4px */
            --space-sm: var(--space-unit);              /* 8px */
            --space-md: calc(var(--space-unit) * 2);    /* 16px */
            --space-lg: calc(var(--space-unit) * 3);    /* 24px */
            --space-xl: calc(var(--space-unit) * 4);    /* 32px */
            
            /* Typography */
            --font-family: Arial, sans-serif;
            --font-size-base: 14px;
            --font-size-sm: 12px;
            --font-size-lg: 16px;
            --font-weight-normal: 400;
            --font-weight-bold: 600;
            --line-height: 1.6;
            
            /* Layout */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            
            /* Node dimensions */
            --node-size: 60px;
            --node-emoji-size: 24px;
        }
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            color: var(--color-text);
            background-color: var(--color-bg);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Application Layout */
        .header {
            background-color: var(--color-surface);
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            margin: 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .version {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            font-weight: var(--font-weight-normal);
            margin-left: var(--space-sm);
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--color-bg);
        }
        
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .editor-container {
            width: 40%;
            display: flex;
            flex-direction: column;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            overflow: hidden;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: var(--space-sm);
        }
        
        button {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-surface-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: var(--font-size-base);
            transition: background-color var(--transition-fast);
        }
        
        button:hover {
            background-color: var(--color-border);
        }
        
        button:active {
            background-color: var(--color-border);
        }
        
        button.primary {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        button.primary:hover {
            background-color: var(--color-primary-dark);
        }
        
        /* Editor Styles */
        .editor-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface-alt);
        }
        
        .editor-title {
            margin: 0 0 var(--space-xs) 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .node-emoji {
            font-size: 1.2em;
        }
        
        .editor-subtitle {
            color: var(--color-text-muted);
            font-size: var(--font-size-base);
            margin: 0;
        }
        
        .editor-content {
            flex: 1;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-placeholder {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-muted);
            font-style: italic;
            text-align: center;
            padding: var(--space-lg);
        }
        
        .name-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        .emoji-input-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }
        
        .emoji-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        #node-emoji-select {
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-lg);
            min-width: 60px;
            cursor: pointer;
        }
        
        #node-name {
            width: 100%;
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            transition: border-color var(--transition-fast);
        }
        
        #node-name:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        #node-content {
            flex: 1;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            resize: none;
            margin-bottom: var(--space-md);
        }
        
        #node-content:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        .editor-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Node tooltip */
        .node-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-sm);
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity var(--transition-fast);
            max-width: 200px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Status Indicator */
        .status {
            position: absolute;
            bottom: var(--space-sm);
            left: var(--space-sm);
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-base);
            color: var(--color-text-muted);
        }

        /* Emoji picker dialog */
        .emoji-picker {
            position: absolute;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            padding: var(--space-md);
            z-index: 100;
            max-width: 300px;
            display: none;
        }
        
        .emoji-picker.active {
            display: block;
        }
        
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }
        
        .emoji-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            border-radius: var(--border-radius-sm);
        }
        
        .emoji-item:hover {
            background-color: var(--color-surface-alt);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">üìù NodePad <span class="version">v1.ü™¥1.0</span></h1>
        <div class="controls">
            <button id="add-node-btn">Add Node</button>
            <button id="export-json-btn">Export JSON</button>
            <button id="export-csv-btn">Export CSVs</button>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Network View (Left Side) -->
        <div class="canvas-container">
            <canvas id="network-canvas"></canvas>
            <div class="node-tooltip" id="node-tooltip"></div>
            <div class="status" id="status">Ready</div>
        </div>
        
        <!-- Node Editor (Right Side) -->
        <div class="editor-container">
            <div class="editor-header">
                <h2 class="editor-title" id="editor-title">Node Editor</h2>
                <p class="editor-subtitle" id="editor-subtitle">Select a node to edit its content</p>
            </div>
            
            <div class="editor-content" id="editor-content">
                <div class="editor-placeholder" id="editor-placeholder">
                    Click on a node in the network view to edit its content
                </div>
                
                <div class="emoji-input-container">
                    <div>
                        <label class="emoji-label" for="node-emoji-select">Node Icon:</label>
                        <button id="node-emoji-select">üå±</button>
                    </div>
                    <div style="flex: 1;">
                        <label class="name-label" for="node-name">Node Title:</label>
                        <input type="text" id="node-name" placeholder="Enter a title for this node">
                    </div>
                </div>
                
                <textarea id="node-content" placeholder="Enter your notes here..."></textarea>
                
                <div class="editor-actions">
                    <button id="update-node-btn" class="primary">Update Node</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Emoji Picker Dialog -->
    <div class="emoji-picker" id="emoji-picker">
        <h3>Select an Emoji</h3>
        <div class="emoji-grid" id="emoji-grid"></div>
    </div>

    <script>
        /**
         * NodePad v1.ü™¥1.0: Visual Knowledge Network
         * 
         * A nonlinear note-taking application that represents ideas as 
         * interconnected nodes in a visual network, making it easier to
         * organize complex thoughts and relationships.
         * 
         * @version 1.ü™¥1.0
         */
        
        document.addEventListener('DOMContentLoaded', function() {
            // =====================================================================
            // META-SYSTEM: Application Metadata and Configuration
            // =====================================================================

            /**
             * META: Application knowledge system
             * 
             * Centralized configuration that serves as a single source of truth
             * for all application parameters.
             * 
             * @version 1.ü™¥1.0 - Refactored for emoji node identifiers
             */
            const META = {
                /** Application version information */
                version: {
                    number: '1.ü™¥1.0',
                    name: 'Visual Knowledge Network',
                    date: '2025-03-31'
                },
                
                /** Debug configuration */
                debug: {
                    enabled: true,
                    prefix: 'NodePad',
                    levels: {
                        info: '‚ÑπÔ∏è',
                        warn: '‚ö†Ô∏è',
                        error: '‚ùå',
                        success: '‚úÖ'
                    }
                },
                
                /** Node configuration */
                node: {
                    defaults: {
                        size: 60,
                        emoji: 'üå±',
                        content: ''
                    },
                    selected: {
                        outlineWidth: 3,
                        outlineColor: '#1890ff'
                    },
                    dragThreshold: 5  // Pixels of movement needed to start dragging
                },
                
                /** Edge configuration */
                edge: {
                    style: {
                        color: '#d9d9d9',
                        width: 1,
                        selectedColor: '#1890ff',
                        selectedWidth: 2
                    }
                },
                
                /** Export configuration */
                export: {
                    formats: {
                        json: {
                            extension: 'json',
                            contentType: 'application/json'
                        },
                        nodeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-nodes.csv'
                        },
                        edgeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-edges.csv'
                        }
                    }
                },
                
                /** Emoji picker configuration */
                emojiPicker: {
                    emojis: [
                        'üå±', 'üåø', 'üå≥', 'üçÇ', 'üîÆ', 'üìù', 'üí°', 'üîç', 
                        'üìä', 'üìà', 'üìâ', 'üìå', 'üîñ', 'üìö', 'üóÇÔ∏è', 'üìã',
                        '‚úÖ', '‚ùå', '‚ö†Ô∏è', '‚ùì', '‚ùó', 'üí¨', 'üó®Ô∏è', 'üîÑ',
                        'üß©', '‚öôÔ∏è', 'üîß', 'üî®', '‚è±Ô∏è', 'üìÖ', 'üß†', '‚ù§Ô∏è'
                    ]
                },
                
                /** Templates for static text */
                templates: {
                    welcome: {
                        emoji: 'üìù',
                        name: 'Welcome to NodePad!',
                        content: 'This is your first note in your visual knowledge network.\n\n‚Ä¢ Click nodes to edit their content\n‚Ä¢ Drag nodes to rearrange them\n‚Ä¢ Connect nodes to show relationships\n‚Ä¢ Each node has its own emoji identifier\n\nStart organizing your ideas!'
                    },
                    status: {
                        ready: 'Ready',
                        selected: nodeName => `Selected: ${nodeName}`,
                        created: nodeName => `Created: ${nodeName}`,
                        updated: nodeName => `Updated: ${nodeName}`,
                        exported: format => `Exported ${format} file`
                    }
                }
            };
            
            // =====================================================================
            // TEMPLATES: Reusable Object Factories
            // =====================================================================

            /**
             * Templates: Object factory system
             * 
             * Provides consistent patterns for creating application objects
             * like nodes and edges.
             * 
             * @version 1.ü™¥1.0 - Updated for circular emoji nodes
             */
            const Templates = {
                /**
                 * Creates a new node with specified properties
                 * @param {Object} props - Properties to override defaults
                 * @returns {Object} A new node object
                 */
                createNode: function(props = {}) {
                    const id = props.id || `node-${State.counters.nextNodeId++}`;
                    
                    return {
                        id: id,
                        emoji: props.emoji || META.node.defaults.emoji,
                        name: props.name || '',
                        content: props.content || META.node.defaults.content,
                        x: props.x || 0,
                        y: props.y || 0,
                        size: props.size || META.node.defaults.size
                    };
                },
                
                /**
                 * Creates a new edge between two nodes
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} A new edge object
                 */
                createEdge: function(sourceId, targetId) {
                    return {
                        id: `edge-${State.counters.nextEdgeId++}`,
                        sourceId: sourceId,
                        targetId: targetId
                    };
                }
            };
            
            // =====================================================================
            // STATE: Global Application State
            // =====================================================================

            /**
             * State: Global application state management
             * 
             * Centralizes all application data and state management functions.
             * 
             * @version 1.ü™¥1.0 - Updated for simplified node structure
             */
            const State = {
                /** Graph data containing nodes and edges */
                graph: {
                    nodes: [],
                    edges: []
                },
                
                /** UI state information */
                ui: {
                    selectedNode: null,
                    isDragging: false,
                    draggedNode: null,
                    dragStartX: 0,
                    dragStartY: 0,
                    dragOffsetX: 0,
                    dragOffsetY: 0,
                    hoveredNode: null
                },
                
                /** Global counters */
                counters: {
                    nextNodeId: 1,
                    nextEdgeId: 1
                },
                
                /**
                 * Selects a node and updates UI accordingly
                 * @param {Object|null} node - Node to select or null to deselect
                 */
                selectNode: function(node) {
                    this.ui.selectedNode = node;
                    UI.updateEditor(node);
                    Renderer.draw();
                    
                    if (node) {
                        UI.updateStatus(META.templates.status.selected(node.name));
                    } else {
                        UI.updateStatus(META.templates.status.ready);
                    }
                },
                
                /**
                 * Adds a new node to the graph
                 * @param {Object} nodeProps - Properties for the new node
                 * @returns {Object} The created node
                 */
                addNode: function(nodeProps) {
                    const node = Templates.createNode(nodeProps);
                    this.graph.nodes.push(node);
                    return node;
                },
                
                /**
                 * Connects two nodes with an edge
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} The created edge
                 */
                addEdge: function(sourceId, targetId) {
                    const edge = Templates.createEdge(sourceId, targetId);
                    this.graph.edges.push(edge);
                    return edge;
                },
                
                /**
                 * Finds a node at the specified coordinates
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @returns {Object|null} Node at coordinates or null if none found
                 */
                findNodeAt: function(x, y) {
                    // Search from front to back (later nodes appear on top)
                    for (let i = this.graph.nodes.length - 1; i >= 0; i--) {
                        const node = this.graph.nodes[i];
                        
                        // Distance from point to node center
                        const dx = x - (node.x + node.size / 2);
                        const dy = y - (node.y + node.size / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // If distance is less than radius, point is inside circle
                        if (distance <= node.size / 2) {
                            return node;
                        }
                    }
                    return null;
                },
                
                /**
                 * Updates node properties
                 * @param {string} nodeId - ID of node to update
                 * @param {Object} changes - Properties to update
                 */
                updateNode: function(nodeId, changes) {
                    const node = this.graph.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    // Apply changes
                    Object.assign(node, changes);
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.updated(node.name));
                },
                
                /**
                 * Exports graph data to specified format
                 * @param {string} format - Format to export ('json', 'csv')
                 */
                exportData: function(format) {
                    if (format === 'json') {
                        ExportManager.toJson();
                    } else if (format === 'csv') {
                        ExportManager.toCsv();
                    }
                }
            };
            
            // =====================================================================
            // DOM: Interface to DOM Elements
            // =====================================================================

            /**
             * DOM: Centralized DOM access
             * 
             * Provides a single interface to all DOM elements used by the application.
             * 
             * @version 1.ü™¥1.0 - Added tooltip and emoji picker elements
             */
            const DOM = {
                /** Element references */
                elements: {},
                
                /** Canvas element and context */
                canvas: null,
                ctx: null,
                
                /**
                 * Initializes DOM references
                 * Gathers all necessary DOM elements into a single access point
                 */
                init: function() {
                    // Core elements
                    const ids = [
                        'network-canvas', 'add-node-btn', 'export-json-btn', 'export-csv-btn',
                        'node-name', 'node-content', 'update-node-btn', 'editor-title',
                        'editor-subtitle', 'editor-placeholder', 'status', 'node-tooltip',
                        'node-emoji-select', 'emoji-picker', 'emoji-grid'
                    ];
                    
                    // Populate elements object
                    ids.forEach(id => {
                        this.elements[id] = document.getElementById(id);
                    });
                    
                    // Setup canvas and context
                    this.canvas = this.elements['network-canvas'];
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Ensure canvas is properly sized
                    this.resizeCanvas();
                    
                    // Initialize emoji picker
                    this.initEmojiPicker();
                },
                
                /**
                 * Sets the canvas size to match its container
                 */
                resizeCanvas: function() {
                    const container = document.querySelector('.canvas-container');
                    this.canvas.width = container.offsetWidth;
                    this.canvas.height = container.offsetHeight;
                },
                
                /**
                 * Initialize emoji picker with available options
                 */
                initEmojiPicker: function() {
                    const grid = this.elements['emoji-grid'];
                    if (!grid) return;
                    
                    // Clear existing items
                    grid.innerHTML = '';
                    
                    // Add all emojis
                    META.emojiPicker.emojis.forEach(emoji => {
                        const item = document.createElement('div');
                        item.className = 'emoji-item';
                        item.textContent = emoji;
                        item.setAttribute('data-emoji', emoji);
                        item.addEventListener('click', () => {
                            if (State.ui.selectedNode) {
                                // Update the emoji select button
                                this.elements['node-emoji-select'].textContent = emoji;
                                
                                // Hide the picker
                                this.elements['emoji-picker'].classList.remove('active');
                            }
                        });
                        
                        grid.appendChild(item);
                    });
                    
                    // Set up emoji select button
                    const emojiSelect = this.elements['node-emoji-select'];
                    const emojiPicker = this.elements['emoji-picker'];
                    
                    if (emojiSelect && emojiPicker) {
                        emojiSelect.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // Position the picker near the button
                            const rect = emojiSelect.getBoundingClientRect();
                            emojiPicker.style.top = `${rect.bottom + 5}px`;
                            emojiPicker.style.left = `${rect.left}px`;
                            
                            // Toggle visibility
                            emojiPicker.classList.toggle('active');
                        });
                        
                        // Close picker when clicking outside
                        document.addEventListener('click', (e) => {
                            if (!emojiPicker.contains(e.target) && e.target !== emojiSelect) {
                                emojiPicker.classList.remove('active');
                            }
                        });
                    }
                }
            };
            
            // =====================================================================
            // UI: User Interface Management
            // =====================================================================

            /**
             * UI: User interface controller
             * 
             * Handles all updates to the user interface based on application state.
             * 
             * @version 1.ü™¥1.0 - Updated for emoji node identifiers
             */
            const UI = {
                /**
                 * Updates the node editor with node content
                 * @param {Object|null} node - Node to edit or null to clear editor
                 */
                updateEditor: function(node) {
                    const placeholderEl = DOM.elements['editor-placeholder'];
                    const emojiSelectEl = DOM.elements['node-emoji-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    const titleEl = DOM.elements['editor-title'];
                    const subtitleEl = DOM.elements['editor-subtitle'];
                    const updateBtnEl = DOM.elements['update-node-btn'];
                    const emojiPickerEl = DOM.elements['emoji-picker'];
                    
                    // Hide emoji picker if open
                    if (emojiPickerEl) {
                        emojiPickerEl.classList.remove('active');
                    }
                    
                    if (node) {
                        // Show editor with node content
                        placeholderEl.style.display = 'none';
                        nameEl.style.display = 'block';
                        contentEl.style.display = 'block';
                        updateBtnEl.style.display = 'block';
                        emojiSelectEl.parentElement.parentElement.style.display = 'flex';
                        
                        // Set content
                        emojiSelectEl.textContent = node.emoji;
                        nameEl.value = node.name || '';
                        contentEl.value = node.content || '';
                        
                        // Update headings
                        titleEl.innerHTML = `<span class="node-emoji">${node.emoji}</span> Editing ${node.name || 'Untitled Node'}`;
                        subtitleEl.textContent = 'Make changes and click "Update Node" to save';
                    } else {
                        // Hide editor, show placeholder
                        placeholderEl.style.display = 'flex';
                        nameEl.style.display = 'none';
                        contentEl.style.display = 'none';
                        updateBtnEl.style.display = 'none';
                        emojiSelectEl.parentElement.parentElement.style.display = 'none';
                        
                        // Update headings
                        titleEl.textContent = 'Node Editor';
                        subtitleEl.textContent = 'Select a node to edit its content';
                    }
                },
                
                /**
                 * Show node tooltip at specified position
                 * @param {Object} node - Node to show tooltip for
                 * @param {number} x - X position
                 * @param {number} y - Y position 
                 */
                showNodeTooltip: function(node, x, y) {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    // Set tooltip content and position
                    tooltip.textContent = node.name || 'Untitled Node';
                    tooltip.style.left = `${x}px`;
                    tooltip.style.top = `${y - 30}px`;
                    tooltip.style.opacity = '1';
                    
                    // Update hovered node reference
                    State.ui.hoveredNode = node;
                },
                
                /**
                 * Hide node tooltip
                 */
                hideNodeTooltip: function() {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    tooltip.style.opacity = '0';
                    State.ui.hoveredNode = null;
                },
                
                /**
                 * Updates the status message
                 * @param {string} message - Status message to display
                 * @param {number} [duration=3000] - Duration to show message in ms
                 */
                updateStatus: function(message, duration = 3000) {
                    const statusEl = DOM.elements.status;
                    if (!statusEl) return;
                    
                    // Set message
                    statusEl.textContent = message;
                    Debug.log(`Status: ${message}`);
                    
                    // Clear after duration
                    setTimeout(() => {
                        if (statusEl.textContent === message) {
                            statusEl.textContent = State.ui.selectedNode ? 
                                META.templates.status.selected(State.ui.selectedNode.name || 'Untitled Node') : 
                                META.templates.status.ready;
                        }
                    }, duration);
                }
            };
            
            // =====================================================================
            // RENDERER: Canvas Drawing System
            // =====================================================================

            /**
             * Renderer: Visual drawing system
             * 
             * Handles all drawing operations on the canvas, visualizing
             * the nodes and edges in the network.
             * 
             * @version 1.ü™¥1.0 - Completely rewritten for circular emoji nodes
             */
            const Renderer = {
                /**
                 * Draws the complete graph
                 * Renders all nodes and edges on the canvas
                 */
                draw: function() {
                    const ctx = DOM.ctx;
                    const canvas = DOM.canvas;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw all edges
                    this.drawEdges();
                    
                    // Draw all nodes
                    this.drawNodes();
                },
                
                /**
                 * Draws all edges in the graph
                 */
                drawEdges: function() {
                    const ctx = DOM.ctx;
                    const edges = State.graph.edges;
                    
                    // Set default edge style
                    ctx.strokeStyle = META.edge.style.color;
                    ctx.lineWidth = META.edge.style.width;
                    
                    edges.forEach(edge => {
                        // Find connected nodes
                        const sourceNode = State.graph.nodes.find(n => n.id === edge.sourceId);
                        const targetNode = State.graph.nodes.find(n => n.id === edge.targetId);
                        
                        // Skip if either node is missing
                        if (!sourceNode || !targetNode) return;
                        
                        // Calculate connection points (center of nodes)
                        const sourceX = sourceNode.x + sourceNode.size / 2;
                        const sourceY = sourceNode.y + sourceNode.size / 2;
                        const targetX = targetNode.x + targetNode.size / 2;
                        const targetY = targetNode.y + targetNode.size / 2;
                        
                        // Draw connecting line
                        ctx.beginPath();
                        ctx.moveTo(sourceX, sourceY);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                    });
                },
                
                /**
                 * Draws all nodes in the graph
                 */
                drawNodes: function() {
                    const nodes = State.graph.nodes;
                    
                    nodes.forEach(node => {
                        this.drawNode(node);
                    });
                },
                
                /**
                 * Draws a single node
                 * @param {Object} node - Node to draw
                 */
                drawNode: function(node) {
                    const ctx = DOM.ctx;
                    const isSelected = node === State.ui.selectedNode;
                    
                    // Calculate center position
                    const centerX = node.x + node.size / 2;
                    const centerY = node.y + node.size / 2;
                    const radius = node.size / 2;
                    
                    // Draw node background circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    // Fill with gradient
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius * 0.7,
                        centerX, centerY, radius
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(1, '#f0f0f0');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw outline, thicker if selected
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#d9d9d9';
                        ctx.lineWidth = 1;
                    }
                    
                    ctx.stroke();
                    
                    // Draw emoji in center
                    ctx.font = `${node.size * 0.4}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.emoji, centerX, centerY);
                }
            };
            
            // =====================================================================
            // INPUT: User Interaction Handler
            // =====================================================================

            /**
             * InputHandler: Interaction management
             * 
             * Handles all user interactions with the application,
             * including mouse events, keyboard input, and button clicks.
             * 
             * @version 1.ü™¥1.0 - Updated for circular node interactions
             */
            const InputHandler = {
                /**
                 * Sets up all event listeners
                 */
                init: function() {
                    // Canvas mouse events
                    DOM.canvas.addEventListener('mousedown', this.handleMouseDown);
                    DOM.canvas.addEventListener('mousemove', this.handleMouseMove);
                    DOM.canvas.addEventListener('mouseup', this.handleMouseUp);
                    DOM.canvas.addEventListener('click', this.handleClick);
                    
                    // Button events
                    DOM.elements['add-node-btn'].addEventListener('click', this.handleAddNode);
                    DOM.elements['export-json-btn'].addEventListener('click', () => State.exportData('json'));
                    DOM.elements['export-csv-btn'].addEventListener('click', () => State.exportData('csv'));
                    DOM.elements['update-node-btn'].addEventListener('click', this.handleUpdateNode);
                    
                    // Window resize event
                    window.addEventListener('resize', () => {
                        DOM.resizeCanvas();
                        Renderer.draw();
                    });
                },
                
                /**
                 * Handles mouse down event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseDown: function(e) {
                    // Get mouse position relative to canvas
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find node under cursor
                    const node = State.findNodeAt(x, y);
                    
                    if (node) {
                        // Set drag start position
                        State.ui.dragStartX = x;
                        State.ui.dragStartY = y;
                        State.ui.draggedNode = node;
                        
                        // Calculate offset from the top-left corner of the node
                        State.ui.dragOffsetX = x - node.x;
                        State.ui.dragOffsetY = y - node.y;
                        
                        // Don't set isDragging yet - wait for movement threshold
                        
                        // Change cursor
                        DOM.canvas.style.cursor = 'grabbing';
                    }
                },
                
                /**
                 * Handles mouse move event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseMove: function(e) {
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Handle dragging - wait for movement threshold
                    if (State.ui.draggedNode) {
                        // Check if we've moved enough to start dragging
                        const dragDistance = Math.sqrt(
                            Math.pow(x - State.ui.dragStartX, 2) + 
                            Math.pow(y - State.ui.dragStartY, 2)
                        );
                        
                        if (dragDistance >= META.node.dragThreshold || State.ui.isDragging) {
                            // Start dragging if we haven't already
                            State.ui.isDragging = true;
                            
                            // Update node position
                            State.ui.draggedNode.x = x - State.ui.dragOffsetX;
                            State.ui.draggedNode.y = y - State.ui.dragOffsetY;
                            Renderer.draw();
                        }
                    } else {
                        // Check for node hovering for tooltip
                        const hoveredNode = State.findNodeAt(x, y);
                        
                        if (hoveredNode) {
                            // Show tooltip
                            UI.showNodeTooltip(hoveredNode, x, y);
                            // Update cursor
                            DOM.canvas.style.cursor = 'grab';
                        } else {
                            // Hide tooltip
                            UI.hideNodeTooltip();
                            // Reset cursor
                            DOM.canvas.style.cursor = 'default';
                        }
                    }
                },
                
                /**
                 * Handles mouse up event
                 */
                handleMouseUp: function() {
                    // End dragging
                    State.ui.isDragging = false;
                    State.ui.draggedNode = null;
                    
                    // Reset cursor
                    DOM.canvas.style.cursor = 'default';
                },
                
                /**
                 * Handles mouse click event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleClick: function(e) {
                    // Ignore if we were dragging
                    if (State.ui.isDragging) return;
                    
                    // Get mouse position
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find and select node
                    const node = State.findNodeAt(x, y);
                    State.selectNode(node);
                },
                
                /**
                 * Handles adding a new node
                 */
                handleAddNode: function() {
                    // Calculate position for new node
                    const canvas = DOM.canvas;
                    const nodeSize = META.node.defaults.size;
                    const centerX = canvas.width / 2 - nodeSize / 2;
                    const centerY = canvas.height / 2 - nodeSize / 2;
                    
                    // Add offset if there's a selected node
                    let x = centerX;
                    let y = centerY;
                    
                    if (State.ui.selectedNode) {
                        x = State.ui.selectedNode.x + nodeSize * 2;
                        y = State.ui.selectedNode.y;
                        
                        // Create edge from selected to new node
                        const newNode = State.addNode({ x, y });
                        State.addEdge(State.ui.selectedNode.id, newNode.id);
                        State.selectNode(newNode);
                    } else {
                        // Create node at center if no selection
                        const newNode = State.addNode({ 
                            x, y, 
                            emoji: META.templates.welcome.emoji,
                            name: META.templates.welcome.name,
                            content: META.templates.welcome.content
                        });
                        State.selectNode(newNode);
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.created(State.ui.selectedNode.name));
                },
                
                /**
                 * Handles updating a node
                 */
                handleUpdateNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get values from editor
                    const emojiEl = DOM.elements['node-emoji-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    
                    // Update node
                    State.updateNode(State.ui.selectedNode.id, {
                        emoji: emojiEl.textContent,
                        name: nameEl.value,
                        content: contentEl.value
                    });
                    
                    // Update editor title
                    const titleEl = DOM.elements['editor-title'];
                    titleEl.innerHTML = `<span class="node-emoji">${emojiEl.textContent}</span> Editing ${nameEl.value || 'Untitled Node'}`;
                }
            };
            
            // =====================================================================
            // EXPORT: Data Export Functionality
            // =====================================================================

            /**
             * ExportManager: Data export system
             * 
             * Handles exporting graph data to different formats.
             * 
             * @version 1.ü™¥1.0 - Updated for new node structure
             */
            const ExportManager = {
                /**
                 * Exports graph to JSON
                 */
                toJson: function() {
                    // Create a copy of the graph data
                    const graphData = JSON.stringify(State.graph, null, 2);
                    
                    // Download as file
                    this.downloadFile(graphData, 'nodepad.json', META.export.formats.json.contentType);
                    UI.updateStatus(META.templates.status.exported('JSON'));
                },
                
                /**
                 * Exports graph to CSV files
                 */
                toCsv: function() {
                    // Create nodes CSV
                    const nodeHeader = 'id,emoji,name,content,x,y,size\n';
                    const nodeRows = State.graph.nodes.map(node => {
                        // Escape content for CSV
                        const escapedContent = `"${node.content.replace(/"/g, '""')}"`;
                        const escapedName = `"${(node.name || '').replace(/"/g, '""')}"`;
                        const escapedEmoji = `"${node.emoji}"`;
                        
                        return `${node.id},${escapedEmoji},${escapedName},${escapedContent},${node.x},${node.y},${node.size}`;
                    }).join('\n');
                    
                    const nodesCSV = nodeHeader + nodeRows;
                    
                    // Create edges CSV
                    const edgeHeader = 'id,sourceId,targetId\n';
                    const edgeRows = State.graph.edges.map(edge => {
                        return `${edge.id},${edge.sourceId},${edge.targetId}`;
                    }).join('\n');
                    
                    const edgesCSV = edgeHeader + edgeRows;
                    
                    // Download both files
                    this.downloadFile(nodesCSV, META.export.formats.nodeCsv.filename, META.export.formats.nodeCsv.contentType);
                    this.downloadFile(edgesCSV, META.export.formats.edgeCsv.filename, META.export.formats.edgeCsv.contentType);
                    
                    UI.updateStatus(META.templates.status.exported('CSV'));
                },
                
                /**
                 * Creates and triggers download for a file
                 * @param {string} content - File content
                 * @param {string} fileName - File name
                 * @param {string} contentType - File MIME type
                 */
                downloadFile: function(content, fileName, contentType) {
                    // Create blob and download link
                    const blob = new Blob([content], { type: contentType });
                    const url = URL.createObjectURL(blob);
                    
                    // Create and trigger download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    
                    // Cleanup
                    URL.revokeObjectURL(url);
                }
            };
            
            // =====================================================================
            // DEBUG: Debugging Utilities
            // =====================================================================

            /**
             * Debug: Debugging toolkit
             * 
             * Provides consistent debugging output and error handling.
             * 
             * @version 1.ü™¥1.0 - Maintained from previous version
             */
            const Debug = {
                /**
                 * Logs a debug message
                 * @param {string} message - Message to log
                 * @param {string} [level='info'] - Log level
                 */
                log: function(message, level = 'info') {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels[level] || META.debug.levels.info;
                    console.log(`${emoji} ${prefix} v${META.version.number}: ${message}`);
                },
                
                /**
                 * Logs an error message
                 * @param {string} message - Error message
                 * @param {Error} [error] - Error object
                 */
                error: function(message, error) {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels.error;
                    console.error(`${emoji} ${prefix} v${META.version.number}: ${message}`, error || '');
                },
                
                /**
                 * Logs a success message
                 * @param {string} message - Success message
                 */
                success: function(message) {
                    this.log(message, 'success');
                }
            };
            
            // =====================================================================
            // APP: Application Initialization
            // =====================================================================

            /**
             * App: Main application controller
             * 
             * Handles the initialization and startup of the application.
             * 
             * @version 1.ü™¥1.0 - Maintained from previous version
             */
            const App = {
                /**
                 * Initializes the application
                 */
                init: function() {
                    // Initialize DOM references
                    DOM.init();
                    
                    // Set up event handlers
                    InputHandler.init();
                    
                    // Create initial node if no nodes exist
                    if (State.graph.nodes.length === 0) {
                        InputHandler.handleAddNode();
                    }
                    
                    // Render initial state
                    Renderer.draw();
                    
                    Debug.success('Application initialized');
                    UI.updateStatus(`Welcome to NodePad v${META.version.number}!`);
                    
                    return this;
                }
            };
            
            // =====================================================================
            // Initialize the application when DOM is loaded
            // =====================================================================
            
            // Start the application
            App.init();
        });
    </script>
</body>
</html>