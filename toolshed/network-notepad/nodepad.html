<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodePad v1.0.0</title>
    <!-- 
        üå± NodePad: Nonlinear Knowledge Network
        
        Version History:
        v1.0.0 - Initial implementation with constructivist architecture and knot-compacted code
        
        DocTrellis Feature Status:
        üå± Core Architecture - Seedling - Constructivist template system with metadata-driven design
        üå± Node Management - Seedling - Create, select, edit, and drag nodes
        üå± Edge Connections - Seedling - Connections between nodes
        üå± Network View - Seedling - Canvas-based visualization
        üå± Export/Import - Seedling - JSON and CSV export functionality
    -->
    <style>
        /* üå± META System: Constructivist CSS Architecture */
        
        /* Base Variables - Single Source of Truth */
        :root {
            /* Color Palette */
            --color-bg: #fafafa;
            --color-surface: #ffffff;
            --color-surface-alt: #f5f5f5;
            --color-border: #dddddd;
            --color-text: #333333;
            --color-text-muted: #666666;
            --color-primary: #1890ff;
            --color-primary-dark: #096dd9;
            --color-success: #52c41a;
            --color-warning: #faad14;
            --color-error: #f5222d;
            
            /* Spacing System */
            --space-unit: 8px;
            --space-xs: calc(var(--space-unit) * 0.5);  /* 4px */
            --space-sm: var(--space-unit);              /* 8px */
            --space-md: calc(var(--space-unit) * 2);    /* 16px */
            --space-lg: calc(var(--space-unit) * 3);    /* 24px */
            --space-xl: calc(var(--space-unit) * 4);    /* 32px */
            
            /* Typography */
            --font-family: Arial, sans-serif;
            --font-size-base: 14px;
            --font-size-sm: 12px;
            --font-size-lg: 16px;
            --font-weight-normal: 400;
            --font-weight-bold: 600;
            --line-height: 1.6;
            
            /* Layout */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            
            /* Node Dimensions */
            --node-min-width: 150px;
            --node-min-height: 120px;
            --node-header-height: 30px;
        }
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            color: var(--color-text);
            background-color: var(--color-bg);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* üå± Application Layout */
        .header {
            background-color: var(--color-surface);
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            margin: 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .version {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            font-weight: var(--font-weight-normal);
            margin-left: var(--space-sm);
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--color-bg);
        }
        
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .editor-container {
            width: 40%;
            display: flex;
            flex-direction: column;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            overflow: hidden;
        }
        
        /* üå± Controls */
        .controls {
            display: flex;
            gap: var(--space-sm);
        }
        
        button {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-surface-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: var(--font-size-base);
            transition: background-color var(--transition-fast);
        }
        
        button:hover {
            background-color: var(--color-border);
        }
        
        button:active {
            background-color: var(--color-border);
        }
        
        button.primary {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        button.primary:hover {
            background-color: var(--color-primary-dark);
        }
        
        /* üå± Editor Styles */
        .editor-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface-alt);
        }
        
        .editor-title {
            margin: 0 0 var(--space-xs) 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
        }
        
        .editor-subtitle {
            color: var(--color-text-muted);
            font-size: var(--font-size-base);
            margin: 0;
        }
        
        .editor-content {
            flex: 1;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-placeholder {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-muted);
            font-style: italic;
            text-align: center;
            padding: var(--space-lg);
        }
        
        .name-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        #node-name {
            width: 100%;
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            margin-bottom: var(--space-md);
            transition: border-color var(--transition-fast);
        }
        
        #node-name:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        #node-content {
            flex: 1;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            resize: none;
            margin-bottom: var(--space-md);
        }
        
        #node-content:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        .editor-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .size-controls {
            display: flex;
            gap: var(--space-md);
        }
        
        .dimension-control {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }
        
        .dimension-label {
            display: flex;
            align-items: center;
            font-size: var(--font-size-lg);
            margin-right: var(--space-xs);
        }
        
        .size-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-size-lg);
        }
        
        /* üå± Status Indicator */
        .status {
            position: absolute;
            bottom: var(--space-sm);
            left: var(--space-sm);
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-base);
            color: var(--color-text-muted);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">üìù NodePad <span class="version">v1.0.0</span></h1>
        <div class="controls">
            <button id="add-node-btn">Add Node</button>
            <button id="export-json-btn">Export JSON</button>
            <button id="export-csv-btn">Export CSVs</button>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Network View (Left Side) -->
        <div class="canvas-container">
            <canvas id="network-canvas"></canvas>
            <div class="status" id="status">Ready</div>
        </div>
        
        <!-- Node Editor (Right Side) -->
        <div class="editor-container">
            <div class="editor-header">
                <h2 class="editor-title" id="editor-title">Node Editor</h2>
                <p class="editor-subtitle" id="editor-subtitle">Select a node to edit its content</p>
            </div>
            
            <div class="editor-content" id="editor-content">
                <div class="editor-placeholder" id="editor-placeholder">
                    Click on a node in the network view to edit its content
                </div>
                
                <label class="name-label" for="node-name">Node Name:</label>
                <input type="text" id="node-name" placeholder="Enter a name for this node">
                
                <textarea id="node-content" placeholder="Enter your notes here..."></textarea>
                
                <div class="editor-actions">
                    <div class="size-controls">
                        <div class="dimension-control">
                            <span class="dimension-label">‚ÜïÔ∏è</span>
                            <button class="size-btn" id="height-decrease">-</button>
                            <button class="size-btn" id="height-increase">+</button>
                        </div>
                        <div class="dimension-control">
                            <span class="dimension-label">‚ÜîÔ∏è</span>
                            <button class="size-btn" id="width-decrease">-</button>
                            <button class="size-btn" id="width-increase">+</button>
                        </div>
                        <div class="dimension-control">
                            <span class="dimension-label">üé®</span>
                            <button class="size-btn" id="toggle-style">‚Ü∫</button>
                        </div>
                    </div>
                    <button id="update-node-btn" class="primary">Update Node</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * üå± NodePad: Nonlinear Knowledge Network
         * 
         * A constructivist approach to knowledge mapping that enables
         * interconnected thoughts through a visual network interface.
         * 
         * This implementation follows constructivist principles:
         * - Code as a learning artifact
         * - Learning through construction
         * - Explicit over implicit patterns
         * - Self-documenting architecture
         * 
         * We use the META framework:
         * - Metadata: Explicit knowledge representation
         * - Extraction: Atomic understanding units
         * - Templates: Consistent patterns
         * - Assembly: Clear learning pathways
         * 
         * Version: 1.0.0
         */
        
        document.addEventListener('DOMContentLoaded', function() {
            // =====================================================================
            // üå± META-SYSTEM: Application Metadata and Configuration
            // =====================================================================

            /**
             * @metadata Defines application-wide constants and configuration
             * A single source of truth for all configurable parameters
             */
            const META = {
                /** Application version information */
                version: {
                    number: '1.0.0',
                    name: 'Constructivist Foundation',
                    date: '2025-03-31'
                },
                
                /** Debug configuration */
                debug: {
                    enabled: true,
                    prefix: 'üîç NodePad',
                    levels: {
                        info: 'üìò',
                        warn: '‚ö†Ô∏è',
                        error: '‚ùå',
                        success: '‚úÖ'
                    }
                },
                
                /** Node configuration */
                node: {
                    defaults: {
                        width: 250,
                        height: 200,
                        style: 'standard',
                        content: ''
                    },
                    constraints: {
                        minWidth: 150,
                        minHeight: 120,
                        maxWidth: 500,
                        maxHeight: 400,
                        resizeStep: 20
                    },
                    rendering: {
                        headerHeight: 30,
                        textPadding: 15,
                        lineHeight: 20,
                        borderRadius: 4
                    }
                },
                
                /** Available node rendering styles */
                nodeStyles: {
                    standard: {
                        id: 'standard',
                        name: 'Standard',
                        colors: {
                            background: '#ffffff',
                            selectedBackground: '#e6f7ff',
                            header: '#f5f5f5',
                            selectedHeader: '#bae7ff',
                            border: '#d9d9d9',
                            selectedBorder: '#1890ff',
                            text: '#000000'
                        }
                    },
                    minimal: {
                        id: 'minimal',
                        name: 'Minimal',
                        colors: {
                            background: '#f8f9fa',
                            selectedBackground: '#e3f2fd',
                            header: '#edf2f7',
                            selectedHeader: '#bbdefb',
                            border: '#cbd5e0',
                            selectedBorder: '#64b5f6',
                            text: '#1a202c'
                        }
                    }
                },
                
                /** Edge configuration */
                edge: {
                    style: {
                        color: '#d9d9d9',
                        width: 1,
                        selectedColor: '#1890ff',
                        selectedWidth: 2
                    }
                },
                
                /** Export configuration */
                export: {
                    formats: {
                        json: {
                            extension: 'json',
                            contentType: 'application/json'
                        },
                        nodeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-nodes.csv'
                        },
                        edgeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-edges.csv'
                        }
                    }
                },
                
                /** Templates for static text */
                templates: {
                    welcome: {
                        nodeName: 'Welcome Note',
                        nodeContent: 'Welcome to NodePad!\n\nThis is a space for your interconnected thoughts and ideas.\n\n‚Ä¢ Click nodes to edit their content\n‚Ä¢ Drag nodes to rearrange them\n‚Ä¢ Connect nodes to show relationships\n‚Ä¢ Use the controls to customize nodes\n\nStart organizing your knowledge network!'
                    },
                    status: {
                        ready: 'Ready',
                        selected: nodeId => `Selected: ${nodeId}`,
                        created: nodeId => `Created node: ${nodeId}`,
                        updated: nodeId => `Updated: ${nodeId}`,
                        exported: format => `Exported ${format} file`,
                        resized: dimension => `Resized ${dimension}`
                    }
                }
            };
            
            // =====================================================================
            // üå± TEMPLATES: Reusable Object Factories
            // =====================================================================

            /**
             * @template System for creating consistent objects
             * Provides factories for creating nodes, edges, and other application objects
             */
            const Templates = {
                /**
                 * Creates a new node with specified properties
                 * @param {Object} props - Properties to override defaults
                 * @returns {Object} A new node object
                 */
                createNode: function(props = {}) {
                    const id = props.id || `node-${State.counters.nextNodeId++}`;
                    
                    return {
                        id: id,
                        name: props.name || '',
                        content: props.content || META.node.defaults.content,
                        x: props.x || 0,
                        y: props.y || 0,
                        width: props.width || META.node.defaults.width,
                        height: props.height || META.node.defaults.height,
                        style: props.style || META.node.defaults.style
                    };
                },
                
                /**
                 * Creates a new edge between two nodes
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} A new edge object
                 */
                createEdge: function(sourceId, targetId) {
                    return {
                        id: `edge-${State.counters.nextEdgeId++}`,
                        sourceId: sourceId,
                        targetId: targetId
                    };
                }
            };
            
            // =====================================================================
            // üå± STATE: Global Application State
            // =====================================================================

            /**
             * @state Central state management
             * Maintains the application state and provides methods for manipulation
             */
            const State = {
                /** Graph data containing nodes and edges */
                graph: {
                    nodes: [],
                    edges: []
                },
                
                /** UI state information */
                ui: {
                    selectedNode: null,
                    isDragging: false,
                    draggedNode: null,
                    dragOffsetX: 0,
                    dragOffsetY: 0
                },
                
                /** Global counters */
                counters: {
                    nextNodeId: 1,
                    nextEdgeId: 1
                },
                
                /**
                 * Selects a node and updates UI accordingly
                 * @param {Object|null} node - Node to select or null to deselect
                 */
                selectNode: function(node) {
                    this.ui.selectedNode = node;
                    UI.updateEditor(node);
                    Renderer.draw();
                    
                    if (node) {
                        UI.updateStatus(META.templates.status.selected(node.name || node.id));
                    } else {
                        UI.updateStatus(META.templates.status.ready);
                    }
                },
                
                /**
                 * Adds a new node to the graph
                 * @param {Object} nodeProps - Properties for the new node
                 * @returns {Object} The created node
                 */
                addNode: function(nodeProps) {
                    const node = Templates.createNode(nodeProps);
                    this.graph.nodes.push(node);
                    return node;
                },
                
                /**
                 * Connects two nodes with an edge
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} The created edge
                 */
                addEdge: function(sourceId, targetId) {
                    const edge = Templates.createEdge(sourceId, targetId);
                    this.graph.edges.push(edge);
                    return edge;
                },
                
                /**
                 * Finds a node at the specified coordinates
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @returns {Object|null} Node at coordinates or null if none found
                 */
                findNodeAt: function(x, y) {
                    // Search from front to back (later nodes appear on top)
                    for (let i = this.graph.nodes.length - 1; i >= 0; i--) {
                        const node = this.graph.nodes[i];
                        if (x >= node.x && x <= node.x + node.width &&
                            y >= node.y && y <= node.y + node.height) {
                            return node;
                        }
                    }
                    return null;
                },
                
                /**
                 * Updates node content and name
                 * @param {string} nodeId - ID of node to update
                 * @param {Object} changes - Properties to update
                 */
                updateNode: function(nodeId, changes) {
                    const node = this.graph.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    // Apply changes
                    Object.assign(node, changes);
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.updated(node.name || node.id));
                },
                
                /**
                 * Exports graph data to specified format
                 * @param {string} format - Format to export ('json', 'csv')
                 */
                exportData: function(format) {
                    if (format === 'json') {
                        ExportManager.toJson();
                    } else if (format === 'csv') {
                        ExportManager.toCsv();
                    }
                }
            };
            
            // =====================================================================
            // üå± DOM: Interface to DOM Elements
            // =====================================================================

            /**
             * @dom Access to DOM elements
             * Provides centralized access to all DOM elements used by the application
             */
            const DOM = {
                /** Element references */
                elements: {},
                
                /** Canvas element and context */
                canvas: null,
                ctx: null,
                
                /**
                 * Initializes DOM references
                 * Gathers all necessary DOM elements into a single access point
                 */
                init: function() {
                    // Core elements
                    const ids = [
                        'network-canvas', 'add-node-btn', 'export-json-btn', 'export-csv-btn',
                        'node-name', 'node-content', 'update-node-btn', 'editor-title',
                        'editor-subtitle', 'editor-placeholder', 'status', 'canvasContainer',
                        'height-decrease', 'height-increase', 'width-decrease', 'width-increase',
                        'toggle-style'
                    ];
                    
                    // Populate elements object
                    ids.forEach(id => {
                        this.elements[id] = document.getElementById(id);
                    });
                    
                    // Setup canvas and context
                    this.canvas = this.elements['network-canvas'];
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Ensure canvas is properly sized
                    this.resizeCanvas();
                },
                
                /**
                 * Sets the canvas size to match its container
                 */
                resizeCanvas: function() {
                    const container = document.querySelector('.canvas-container');
                    this.canvas.width = container.offsetWidth;
                    this.canvas.height = container.offsetHeight;
                }
            };
            
            // =====================================================================
            // üå± UI: User Interface Management
            // =====================================================================

            /**
             * @ui Interface management
             * Handles updating the UI based on application state
             */
            const UI = {
                /**
                 * Updates the node editor with node content
                 * @param {Object|null} node - Node to edit or null to clear editor
                 */
                updateEditor: function(node) {
                    const placeholderEl = DOM.elements['editor-placeholder'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    const titleEl = DOM.elements['editor-title'];
                    const subtitleEl = DOM.elements['editor-subtitle'];
                    const updateBtnEl = DOM.elements['update-node-btn'];
                    const controls = document.querySelectorAll('.dimension-control');
                    
                    if (node) {
                        // Show editor with node content
                        placeholderEl.style.display = 'none';
                        nameEl.style.display = 'block';
                        contentEl.style.display = 'block';
                        updateBtnEl.style.display = 'block';
                        
                        // Set content
                        nameEl.value = node.name || '';
                        contentEl.value = node.content || '';
                        
                        // Update headings
                        titleEl.textContent = `Editing ${node.name || node.id}`;
                        subtitleEl.textContent = 'Make changes and click "Update Node" to save';
                        
                        // Show controls
                        controls.forEach(c => c.style.display = 'flex');
                    } else {
                        // Hide editor, show placeholder
                        placeholderEl.style.display = 'flex';
                        nameEl.style.display = 'none';
                        contentEl.style.display = 'none';
                        updateBtnEl.style.display = 'none';
                        
                        // Update headings
                        titleEl.textContent = 'Node Editor';
                        subtitleEl.textContent = 'Select a node to edit its content';
                        
                        // Hide controls
                        controls.forEach(c => c.style.display = 'none');
                    }
                },
                
                /**
                 * Updates the status message
                 * @param {string} message - Status message to display
                 * @param {number} [duration=3000] - Duration to show message in ms
                 */
                updateStatus: function(message, duration = 3000) {
                    const statusEl = DOM.elements.status;
                    if (!statusEl) return;
                    
                    // Set message
                    statusEl.textContent = message;
                    Debug.log(`Status: ${message}`);
                    
                    // Clear after duration
                    setTimeout(() => {
                        if (statusEl.textContent === message) {
                            statusEl.textContent = State.ui.selectedNode ? 
                                META.templates.status.selected(State.ui.selectedNode.name || State.ui.selectedNode.id) : 
                                META.templates.status.ready;
                        }
                    }, duration);
                }
            };
            
            // =====================================================================
            // üå± RENDERER: Canvas Drawing System
            // =====================================================================

            /**
             * @renderer Drawing system
             * Handles all rendering operations on the canvas
             */
            const Renderer = {
                /**
                 * Draws the complete graph
                 * Renders all nodes and edges on the canvas
                 */
                draw: function() {
                    const ctx = DOM.ctx;
                    const canvas = DOM.canvas;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw all edges
                    this.drawEdges();
                    
                    // Draw all nodes
                    this.drawNodes();
                },
                
                /**
                 * Draws all edges in the graph
                 */
                drawEdges: function() {
                    const ctx = DOM.ctx;
                    const edges = State.graph.edges;
                    
                    // Set default edge style
                    ctx.strokeStyle = META.edge.style.color;
                    ctx.lineWidth = META.edge.style.width;
                    
                    edges.forEach(edge => {
                        // Find connected nodes
                        const sourceNode = State.graph.nodes.find(n => n.id === edge.sourceId);
                        const targetNode = State.graph.nodes.find(n => n.id === edge.targetId);
                        
                        // Skip if either node is missing
                        if (!sourceNode || !targetNode) return;
                        
                        // Calculate connection points (center of nodes)
                        const sourceX = sourceNode.x + sourceNode.width / 2;
                        const sourceY = sourceNode.y + sourceNode.height / 2;
                        const targetX = targetNode.x + targetNode.width / 2;
                        const targetY = targetNode.y + targetNode.height / 2;
                        
                        // Draw connecting line
                        ctx.beginPath();
                        ctx.moveTo(sourceX, sourceY);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                    });
                },
                
                /**
                 * Draws all nodes in the graph
                 */
                drawNodes: function() {
                    const nodes = State.graph.nodes;
                    
                    nodes.forEach(node => {
                        this.drawNode(node);
                    });
                },
                
                /**
                 * Draws a single node
                 * @param {Object} node - Node to draw
                 */
                drawNode: function(node) {
                    const ctx = DOM.ctx;
                    const isSelected = node === State.ui.selectedNode;
                    const styleTemplate = META.nodeStyles[node.style] || META.nodeStyles.standard;
                    const colors = styleTemplate.colors;
                    const headerHeight = META.node.rendering.headerHeight;
                    const textPadding = META.node.rendering.textPadding;
                    const lineHeight = META.node.rendering.lineHeight;
                    const borderRadius = META.node.rendering.borderRadius;
                    
                    // Set up shadow for depth
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    // Fill and stroke settings based on selection state
                    ctx.fillStyle = isSelected ? colors.selectedBackground : colors.background;
                    ctx.strokeStyle = isSelected ? colors.selectedBorder : colors.border;
                    ctx.lineWidth = isSelected ? 2 : 1;
                    
                    // Draw main rectangle with rounded corners
                    ctx.beginPath();
                    this.roundRect(ctx, node.x, node.y, node.width, node.height, borderRadius);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Reset shadow for other elements
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Draw header background
                    ctx.fillStyle = isSelected ? colors.selectedHeader : colors.header;
                    ctx.beginPath();
                    this.roundRect(ctx, node.x, node.y, node.width, headerHeight, 
                                   [borderRadius, borderRadius, 0, 0]);
                    ctx.fill();
                    
                    // Draw header separator line
                    ctx.strokeStyle = isSelected ? colors.selectedBorder : colors.border;
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y + headerHeight);
                    ctx.lineTo(node.x + node.width, node.y + headerHeight);
                    ctx.stroke();
                    
                    // Draw node name or ID in header
                    ctx.fillStyle = colors.text;
                    ctx.font = `bold 14px var(--font-family)`;
                    const displayName = node.name || node.id;
                    ctx.fillText(displayName, node.x + textPadding, node.y + headerHeight - 10);
                    
                    // Draw content with word wrapping
                    ctx.font = `14px var(--font-family)`;
                    
                    // Get wrapped text lines
                    const maxWidth = node.width - (textPadding * 2);
                    const wrappedText = this.wrapText(ctx, node.content, maxWidth);
                    
                    // Draw each line of text
                    wrappedText.forEach((line, index) => {
                        const y = node.y + headerHeight + textPadding + (index * lineHeight);
                        // Only draw if within node bounds
                        if (y < node.y + node.height - textPadding) {
                            ctx.fillText(line, node.x + textPadding, y);
                        }
                    });
                    
                    // Indicate if content is truncated
                    const contentHeight = wrappedText.length * lineHeight;
                    const maxVisibleHeight = node.height - headerHeight - (textPadding * 2);
                    
                    if (contentHeight > maxVisibleHeight) {
                        ctx.fillStyle = '#999999';
                        ctx.fillText('...', node.x + textPadding, node.y + node.height - textPadding);
                    }
                    
                    // Draw edit indicator if selected
                    if (isSelected) {
                        ctx.fillStyle = colors.selectedBorder;
                        ctx.font = '12px var(--font-family)';
                        ctx.fillText('‚úé Edit', node.x + node.width - 40, node.y + node.height - 10);
                    }
                },
                
                /**
                 * Draws a rounded rectangle
                 * @param {CanvasRenderingContext2D} ctx - Canvas context
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @param {number} width - Rectangle width
                 * @param {number} height - Rectangle height
                 * @param {number|Array} radius - Corner radius or array of corner radii
                 */
                roundRect: function(ctx, x, y, width, height, radius) {
                    // Handle different radius specifications
                    if (typeof radius === 'number') {
                        radius = {tl: radius, tr: radius, br: radius, bl: radius};
                    } else if (Array.isArray(radius)) {
                        const [tl, tr, br, bl] = [...radius, ...Array(4-radius.length).fill(0)];
                        radius = {tl, tr, br, bl};
                    } else {
                        radius = {tl: 0, tr: 0, br: 0, bl: 0};
                    }
                    
                    // Draw rounded rectangle path
                    ctx.beginPath();
                    ctx.moveTo(x + radius.tl, y);
                    ctx.lineTo(x + width - radius.tr, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                    ctx.lineTo(x + width, y + height - radius.br);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                    ctx.lineTo(x + radius.bl, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                    ctx.lineTo(x, y + radius.tl);
                    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
                    ctx.closePath();
                },
                
                /**
                 * Wraps text to fit within a specified width
                 * @param {CanvasRenderingContext2D} ctx - Canvas context
                 * @param {string} text - Text to wrap
                 * @param {number} maxWidth - Maximum width for the text
                 * @returns {Array} Array of text lines
                 */
                wrapText: function(ctx, text, maxWidth) {
                    if (!text) return [];
                    
                    const lines = [];
                    
                    // Handle multi-paragraph text
                    const paragraphs = text.split('\n');
                    
                    paragraphs.forEach(paragraph => {
                        // Add empty line for empty paragraphs
                        if (paragraph === '') {
                            lines.push('');
                            return;
                        }
                        
                        // Split paragraph into words
                        const words = paragraph.split(' ');
                        let currentLine = '';
                        
                        // Process each word
                        words.forEach(word => {
                            // Try adding the word to the current line
                            const testLine = currentLine ? currentLine + ' ' + word : word;
                            const metrics = ctx.measureText(testLine);
                            
                            // If the line becomes too long, start a new one
                            if (metrics.width > maxWidth && currentLine !== '') {
                                lines.push(currentLine);
                                currentLine = word;
                            } else {
                                currentLine = testLine;
                            }
                        });
                        
                        // Add the last line
                        if (currentLine) {
                            lines.push(currentLine);
                        }
                    });
                    
                    return lines;
                }
            };
            
            // =====================================================================
            // üå± INPUT: User Interaction Handler
            // =====================================================================

            /**
             * @input Interaction management
             * Handles mouse and keyboard interactions
             */
            const InputHandler = {
                /**
                 * Sets up all event listeners
                 */
                init: function() {
                    // Canvas mouse events
                    DOM.canvas.addEventListener('mousedown', this.handleMouseDown);
                    DOM.canvas.addEventListener('mousemove', this.handleMouseMove);
                    DOM.canvas.addEventListener('mouseup', this.handleMouseUp);
                    DOM.canvas.addEventListener('click', this.handleClick);
                    
                    // Button events
                    DOM.elements['add-node-btn'].addEventListener('click', this.handleAddNode);
                    DOM.elements['export-json-btn'].addEventListener('click', () => State.exportData('json'));
                    DOM.elements['export-csv-btn'].addEventListener('click', () => State.exportData('csv'));
                    DOM.elements['update-node-btn'].addEventListener('click', this.handleUpdateNode);
                    
                    // Node resize controls
                    DOM.elements['height-decrease'].addEventListener('click', () => this.handleResizeNode('height', -META.node.constraints.resizeStep));
                    DOM.elements['height-increase'].addEventListener('click', () => this.handleResizeNode('height', META.node.constraints.resizeStep));
                    DOM.elements['width-decrease'].addEventListener('click', () => this.handleResizeNode('width', -META.node.constraints.resizeStep));
                    DOM.elements['width-increase'].addEventListener('click', () => this.handleResizeNode('width', META.node.constraints.resizeStep));
                    DOM.elements['toggle-style'].addEventListener('click', this.handleToggleStyle);
                    
                    // Window resize event
                    window.addEventListener('resize', () => {
                        DOM.resizeCanvas();
                        Renderer.draw();
                    });
                },
                
                /**
                 * Handles mouse down event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseDown: function(e) {
                    // Get mouse position relative to canvas
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find node under cursor
                    const node = State.findNodeAt(x, y);
                    
                    if (node) {
                        // Start dragging
                        State.ui.isDragging = true;
                        State.ui.draggedNode = node;
                        State.ui.dragOffsetX = x - node.x;
                        State.ui.dragOffsetY = y - node.y;
                        
                        // Change cursor
                        DOM.canvas.style.cursor = 'grabbing';
                    }
                },
                
                /**
                 * Handles mouse move event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseMove: function(e) {
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Handle dragging
                    if (State.ui.isDragging && State.ui.draggedNode) {
                        // Update node position
                        State.ui.draggedNode.x = x - State.ui.dragOffsetX;
                        State.ui.draggedNode.y = y - State.ui.dragOffsetY;
                        Renderer.draw();
                    } else {
                        // Update cursor style based on hover
                        const node = State.findNodeAt(x, y);
                        DOM.canvas.style.cursor = node ? 'grab' : 'default';
                    }
                },
                
                /**
                 * Handles mouse up event
                 */
                handleMouseUp: function() {
                    // End dragging
                    State.ui.isDragging = false;
                    State.ui.draggedNode = null;
                    
                    // Reset cursor
                    DOM.canvas.style.cursor = 'default';
                },
                
                /**
                 * Handles mouse click event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleClick: function(e) {
                    // Ignore if we just finished dragging
                    if (State.ui.isDragging) return;
                    
                    // Get mouse position
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find and select node
                    const node = State.findNodeAt(x, y);
                    State.selectNode(node);
                },
                
                /**
                 * Handles adding a new node
                 */
                handleAddNode: function() {
                    // Calculate position for new node
                    const canvas = DOM.canvas;
                    const centerX = canvas.width / 2 - META.node.defaults.width / 2;
                    const centerY = canvas.height / 2 - META.node.defaults.height / 2;
                    
                    // Add offset if there's a selected node
                    let x = centerX;
                    let y = centerY;
                    
                    if (State.ui.selectedNode) {
                        x = State.ui.selectedNode.x + State.ui.selectedNode.width + 50;
                        y = State.ui.selectedNode.y;
                        
                        // Create edge from selected to new node
                        const newNode = State.addNode({ x, y });
                        State.addEdge(State.ui.selectedNode.id, newNode.id);
                        State.selectNode(newNode);
                    } else {
                        // Create node at center if no selection
                        const newNode = State.addNode({ 
                            x, y, 
                            name: META.templates.welcome.nodeName,
                            content: META.templates.welcome.nodeContent
                        });
                        State.selectNode(newNode);
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.created(State.ui.selectedNode.id));
                },
                
                /**
                 * Handles updating a node
                 */
                handleUpdateNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get values from editor
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    
                    // Update node
                    State.updateNode(State.ui.selectedNode.id, {
                        name: nameEl.value,
                        content: contentEl.value
                    });
                },
                
                /**
                 * Handles resizing a node
                 * @param {string} dimension - Dimension to resize ('width' or 'height')
                 * @param {number} delta - Amount to change dimension
                 */
                handleResizeNode: function(dimension, delta) {
                    if (!State.ui.selectedNode) return;
                    
                    const node = State.ui.selectedNode;
                    const constraints = META.node.constraints;
                    
                    // Apply resize with constraints
                    if (dimension === 'width') {
                        const newWidth = node.width + delta;
                        node.width = Math.max(constraints.minWidth, Math.min(constraints.maxWidth, newWidth));
                    } else if (dimension === 'height') {
                        const newHeight = node.height + delta;
                        node.height = Math.max(constraints.minHeight, Math.min(constraints.maxHeight, newHeight));
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.resized(dimension));
                },
                
                /**
                 * Handles toggling node style
                 */
                handleToggleStyle: function() {
                    if (!State.ui.selectedNode) return;
                    
                    const node = State.ui.selectedNode;
                    const styles = Object.keys(META.nodeStyles);
                    
                    // Find current style index
                    const currentIndex = styles.indexOf(node.style);
                    
                    // Get next style (or circle back to first)
                    const nextIndex = (currentIndex + 1) % styles.length;
                    node.style = styles[nextIndex];
                    
                    Renderer.draw();
                    UI.updateStatus(`Style changed to ${META.nodeStyles[node.style].name}`);
                }
            };
            
            // =====================================================================
            // üå± EXPORT: Data Export Functionality
            // =====================================================================

            /**
             * @export Export functionality
             * Handles exporting graph data to different formats
             */
            const ExportManager = {
                /**
                 * Exports graph to JSON
                 */
                toJson: function() {
                    // Create a copy of the graph data
                    const graphData = JSON.stringify(State.graph, null, 2);
                    
                    // Download as file
                    this.downloadFile(graphData, 'nodepad.json', META.export.formats.json.contentType);
                    UI.updateStatus(META.templates.status.exported('JSON'));
                },
                
                /**
                 * Exports graph to CSV files
                 */
                toCsv: function() {
                    // Create nodes CSV
                    const nodeHeader = 'id,name,content,x,y,width,height,style\n';
                    const nodeRows = State.graph.nodes.map(node => {
                        // Escape content for CSV
                        const escapedContent = `"${node.content.replace(/"/g, '""')}"`;
                        const escapedName = `"${(node.name || '').replace(/"/g, '""')}"`;
                        
                        return `${node.id},${escapedName},${escapedContent},${node.x},${node.y},${node.width},${node.height},${node.style}`;
                    }).join('\n');
                    
                    const nodesCSV = nodeHeader + nodeRows;
                    
                    // Create edges CSV
                    const edgeHeader = 'id,sourceId,targetId\n';
                    const edgeRows = State.graph.edges.map(edge => {
                        return `${edge.id},${edge.sourceId},${edge.targetId}`;
                    }).join('\n');
                    
                    const edgesCSV = edgeHeader + edgeRows;
                    
                    // Download both files
                    this.downloadFile(nodesCSV, META.export.formats.nodeCsv.filename, META.export.formats.nodeCsv.contentType);
                    this.downloadFile(edgesCSV, META.export.formats.edgeCsv.filename, META.export.formats.edgeCsv.contentType);
                    
                    UI.updateStatus(META.templates.status.exported('CSV'));
                },
                
                /**
                 * Creates and triggers download for a file
                 * @param {string} content - File content
                 * @param {string} fileName - File name
                 * @param {string} contentType - File MIME type
                 */
                downloadFile: function(content, fileName, contentType) {
                    // Create blob and download link
                    const blob = new Blob([content], { type: contentType });
                    const url = URL.createObjectURL(blob);
                    
                    // Create and trigger download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    
                    // Cleanup
                    URL.revokeObjectURL(url);
                }
            };
            
            // =====================================================================
            // üå± DEBUG: Debugging Utilities
            // =====================================================================

            /**
             * @debug Debugging utilities
             * Provides consistent debugging output
             */
            const Debug = {
                /**
                 * Logs a debug message
                 * @param {string} message - Message to log
                 * @param {string} [level='info'] - Log level
                 */
                log: function(message, level = 'info') {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels[level] || META.debug.levels.info;
                    console.log(`${emoji} ${prefix} v${META.version.number}: ${message}`);
                },
                
                /**
                 * Logs an error message
                 * @param {string} message - Error message
                 * @param {Error} [error] - Error object
                 */
                error: function(message, error) {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels.error;
                    console.error(`${emoji} ${prefix} v${META.version.number}: ${message}`, error || '');
                },
                
                /**
                 * Logs a success message
                 * @param {string} message - Success message
                 */
                success: function(message) {
                    this.log(message, 'success');
                }
            };
            
            // =====================================================================
            // üå± APP: Application Initialization
            // =====================================================================

            /**
             * @app Main application
             * Handles initialization and startup
             */
            const App = {
                /**
                 * Initializes the application
                 */
                init: function() {
                    // Initialize DOM references
                    DOM.init();
                    
                    // Set up event handlers
                    InputHandler.init();
                    
                    // Create initial node if no nodes exist
                    if (State.graph.nodes.length === 0) {
                        InputHandler.handleAddNode();
                    }
                    
                    // Render initial state
                    Renderer.draw();
                    
                    Debug.success('Application initialized');
                    UI.updateStatus('Welcome to NodePad!');
                    
                    return this;
                }
            };
            
            // =====================================================================
            // Initialize the application when DOM is loaded
            // =====================================================================
            
            // Start the application
            App.init();
        });
    </script>
</body>
</html>