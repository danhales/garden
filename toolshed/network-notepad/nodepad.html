<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodePad v1.🪴1.0</title>
    <!-- 
        NodePad v1.🪴1.0: Visual Knowledge Network
        
        Version History:
        v0.0.1 - Initial implementation with popup editor and basic node display
        v0.0.2 - Attempted to refactor with Node class architecture (contained bugs)
        v0.0.3 - Fixed edge rendering bug and simplified architecture
        v0.0.4 - Restructured code with proper DocTrellis versioning and modularized components
        v0.0.5 - Fixed node interaction bug with dragging different nodes
        v0.0.6 - Implemented template-based node rendering system
        v0.0.7 - Added ability to edit node names
        v0.1.0 - First minor version with stable core features and cleaned documentation
        v1.0.0 - Complete constructivist rewrite with knot-compacted architecture
        v1.🪴1.0 - Simplified circular nodes with emoji identifiers and hover information
        
        DocTrellis Feature Status:
        🪴 Core Architecture - Potted Plant - Constructivist template system with metadata-driven design
        🪴 Node Management - Potted Plant - Create, select, edit, and drag nodes
        🪴 Edge Connections - Potted Plant - Connections between nodes
        🪴 Network View - Potted Plant - Canvas-based visualization with emoji identifiers
        🌱 Export/Import - Seedling - JSON and CSV export functionality
        
        Leaf Pile (Pruned Ideas):
        🍂 Source Explorer - Browser-based source code exploration using emoji markers
        🍂 Custom node styles - Multiple visual presentation options for node content
    -->
    <style>
        /* Base Variables - Single Source of Truth */
        :root {
            /* Color Palette */
            --color-bg: #fafafa;
            --color-surface: #ffffff;
            --color-surface-alt: #f5f5f5;
            --color-border: #dddddd;
            --color-text: #333333;
            --color-text-muted: #666666;
            --color-primary: #1890ff;
            --color-primary-dark: #096dd9;
            --color-success: #52c41a;
            --color-warning: #faad14;
            --color-error: #f5222d;
            
            /* Spacing System */
            --space-unit: 8px;
            --space-xs: calc(var(--space-unit) * 0.5);  /* 4px */
            --space-sm: var(--space-unit);              /* 8px */
            --space-md: calc(var(--space-unit) * 2);    /* 16px */
            --space-lg: calc(var(--space-unit) * 3);    /* 24px */
            --space-xl: calc(var(--space-unit) * 4);    /* 32px */
            
            /* Typography */
            --font-family: Arial, sans-serif;
            --font-size-base: 14px;
            --font-size-sm: 12px;
            --font-size-lg: 16px;
            --font-weight-normal: 400;
            --font-weight-bold: 600;
            --line-height: 1.6;
            
            /* Layout */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            
            /* Node dimensions */
            --node-size: 60px;
            --node-emoji-size: 24px;
        }
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            color: var(--color-text);
            background-color: var(--color-bg);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Application Layout */
        .header {
            background-color: var(--color-surface);
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            margin: 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .version {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            font-weight: var(--font-weight-normal);
            margin-left: var(--space-sm);
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--color-bg);
        }
        
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .editor-container {
            width: 40%;
            display: flex;
            flex-direction: column;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            overflow: hidden;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: var(--space-sm);
        }
        
        button {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-surface-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: var(--font-size-base);
            transition: background-color var(--transition-fast);
        }
        
        button:hover {
            background-color: var(--color-border);
        }
        
        button:active {
            background-color: var(--color-border);
        }
        
        button.primary {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        button.primary:hover {
            background-color: var(--color-primary-dark);
        }
        
        /* Editor Styles */
        .editor-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface-alt);
        }
        
        .editor-title {
            margin: 0 0 var(--space-xs) 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .node-emoji {
            font-size: 1.2em;
        }
        
        .editor-subtitle {
            color: var(--color-text-muted);
            font-size: var(--font-size-base);
            margin: 0;
        }
        
        .editor-content {
            flex: 1;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-placeholder {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-muted);
            font-style: italic;
            text-align: center;
            padding: var(--space-lg);
        }
        
        .name-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        .emoji-input-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }
        
        .emoji-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        #node-emoji-select {
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-lg);
            min-width: 60px;
            cursor: pointer;
        }
        
        #node-name {
            width: 100%;
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            transition: border-color var(--transition-fast);
        }
        
        #node-name:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        #node-content {
            flex: 1;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            resize: none;
            margin-bottom: var(--space-md);
        }
        
        #node-content:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        .editor-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Node tooltip */
        .node-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-sm);
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity var(--transition-fast);
            max-width: 200px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Status Indicator */
        .status {
            position: absolute;
            bottom: var(--space-sm);
            left: var(--space-sm);
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-base);
            color: var(--color-text-muted);
        }

        /* Emoji picker dialog */
        .emoji-picker {
            position: absolute;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            padding: var(--space-md);
            z-index: 100;
            max-width: 300px;
            display: none;
        }
        
        .emoji-picker.active {
            display: block;
        }
        
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }
        
        .emoji-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            border-radius: var(--border-radius-sm);
        }
        
        .emoji-item:hover {
            background-color: var(--color-surface-alt);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">📝 NodePad <span class="version">v1.🪴1.0</span></h1>
        <div class="controls">
            <button id="add-node-btn">Add Node</button>
            <button id="export-json-btn">Export JSON</button>
            <button id="export-csv-btn">Export CSVs</button>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Network View (Left Side) -->
        <div class="canvas-container">
            <canvas id="network-canvas"></canvas>
            <div class="node-tooltip" id="node-tooltip"></div>
            <div class="status" id="status">Ready</div>
        </div>
        
        <!-- Node Editor (Right Side) -->
        <div class="editor-container">
            <div class="editor-header">
                <h2 class="editor-title" id="editor-title">Node Editor</h2>
                <p class="editor-subtitle" id="editor-subtitle">Select a node to edit its content</p>
            </div>
            
            <div class="editor-content" id="editor-content">
                <div class="editor-placeholder" id="editor-placeholder">
                    Click on a node in the network view to edit its content
                </div>
                
                <div class="emoji-input-container">
                    <div>
                        <label class="emoji-label" for="node-emoji-select">Node Icon:</label>
                        <button id="node-emoji-select">🌱</button>
                    </div>
                    <div style="flex: 1;">
                        <label class="name-label" for="node-name">Node Title:</label>
                        <input type="text" id="node-name" placeholder="Enter a title for this node">
                    </div>
                </div>
                
                <textarea id="node-content" placeholder="Enter your notes here..."></textarea>
                
                <div class="editor-actions">
                    <button id="update-node-btn" class="primary">Update Node</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Emoji Picker Dialog -->
    <div class="emoji-picker" id="emoji-picker">
        <h3>Select an Emoji</h3>
        <div class="emoji-grid" id="emoji-grid"></div>
    </div>

    <script>
        /**
         * NodePad v1.🪴1.0: Visual Knowledge Network
         * 
         * A nonlinear note-taking application that represents ideas as 
         * interconnected nodes in a visual network, making it easier to
         * organize complex thoughts and relationships.
         * 
         * @version 1.🪴1.0
         */
        
        document.addEventListener('DOMContentLoaded', function() {
            // =====================================================================
            // META-SYSTEM: Application Metadata and Configuration
            // =====================================================================

            /**
             * META: Application knowledge system
             * 
             * Centralized configuration that serves as a single source of truth
             * for all application parameters.
             * 
             * @version 1.🪴1.0 - Refactored for emoji node identifiers
             */
            const META = {
                /** Application version information */
                version: {
                    number: '1.🪴1.0',
                    name: 'Visual Knowledge Network',
                    date: '2025-03-31'
                },
                
                /** Debug configuration */
                debug: {
                    enabled: true,
                    prefix: 'NodePad',
                    levels: {
                        info: 'ℹ️',
                        warn: '⚠️',
                        error: '❌',
                        success: '✅'
                    }
                },
                
                /** Node configuration */
                node: {
                    defaults: {
                        size: 60,
                        emoji: '🌱',
                        content: ''
                    },
                    selected: {
                        outlineWidth: 3,
                        outlineColor: '#1890ff'
                    },
                    dragThreshold: 5  // Pixels of movement needed to start dragging
                },
                
                /** Edge configuration */
                edge: {
                    style: {
                        color: '#d9d9d9',
                        width: 1,
                        selectedColor: '#1890ff',
                        selectedWidth: 2
                    }
                },
                
                /** Export configuration */
                export: {
                    formats: {
                        json: {
                            extension: 'json',
                            contentType: 'application/json'
                        },
                        nodeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-nodes.csv'
                        },
                        edgeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-edges.csv'
                        }
                    }
                },
                
                /** Emoji picker configuration */
                emojiPicker: {
                    emojis: [
                        '🌱', '🌿', '🌳', '🍂', '🔮', '📝', '💡', '🔍', 
                        '📊', '📈', '📉', '📌', '🔖', '📚', '🗂️', '📋',
                        '✅', '❌', '⚠️', '❓', '❗', '💬', '🗨️', '🔄',
                        '🧩', '⚙️', '🔧', '🔨', '⏱️', '📅', '🧠', '❤️'
                    ]
                },
                
                /** Templates for static text */
                templates: {
                    welcome: {
                        emoji: '📝',
                        name: 'Welcome to NodePad!',
                        content: 'This is your first note in your visual knowledge network.\n\n• Click nodes to edit their content\n• Drag nodes to rearrange them\n• Connect nodes to show relationships\n• Each node has its own emoji identifier\n\nStart organizing your ideas!'
                    },
                    status: {
                        ready: 'Ready',
                        selected: nodeName => `Selected: ${nodeName}`,
                        created: nodeName => `Created: ${nodeName}`,
                        updated: nodeName => `Updated: ${nodeName}`,
                        exported: format => `Exported ${format} file`
                    }
                }
            };
            
            // =====================================================================
            // TEMPLATES: Reusable Object Factories
            // =====================================================================

            /**
             * Templates: Object factory system
             * 
             * Provides consistent patterns for creating application objects
             * like nodes and edges.
             * 
             * @version 1.🪴1.0 - Updated for circular emoji nodes
             */
            const Templates = {
                /**
                 * Creates a new node with specified properties
                 * @param {Object} props - Properties to override defaults
                 * @returns {Object} A new node object
                 */
                createNode: function(props = {}) {
                    const id = props.id || `node-${State.counters.nextNodeId++}`;
                    
                    return {
                        id: id,
                        emoji: props.emoji || META.node.defaults.emoji,
                        name: props.name || '',
                        content: props.content || META.node.defaults.content,
                        x: props.x || 0,
                        y: props.y || 0,
                        size: props.size || META.node.defaults.size
                    };
                },
                
                /**
                 * Creates a new edge between two nodes
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} A new edge object
                 */
                createEdge: function(sourceId, targetId) {
                    return {
                        id: `edge-${State.counters.nextEdgeId++}`,
                        sourceId: sourceId,
                        targetId: targetId
                    };
                }
            };
            
            // =====================================================================
            // STATE: Global Application State
            // =====================================================================

            /**
             * State: Global application state management
             * 
             * Centralizes all application data and state management functions.
             * 
             * @version 1.🪴1.0 - Updated for simplified node structure
             */
            const State = {
                /** Graph data containing nodes and edges */
                graph: {
                    nodes: [],
                    edges: []
                },
                
                /** UI state information */
                ui: {
                    selectedNode: null,
                    isDragging: false,
                    draggedNode: null,
                    dragStartX: 0,
                    dragStartY: 0,
                    dragOffsetX: 0,
                    dragOffsetY: 0,
                    hoveredNode: null
                },
                
                /** Global counters */
                counters: {
                    nextNodeId: 1,
                    nextEdgeId: 1
                },
                
                /**
                 * Selects a node and updates UI accordingly
                 * @param {Object|null} node - Node to select or null to deselect
                 */
                selectNode: function(node) {
                    this.ui.selectedNode = node;
                    UI.updateEditor(node);
                    Renderer.draw();
                    
                    if (node) {
                        UI.updateStatus(META.templates.status.selected(node.name));
                    } else {
                        UI.updateStatus(META.templates.status.ready);
                    }
                },
                
                /**
                 * Adds a new node to the graph
                 * @param {Object} nodeProps - Properties for the new node
                 * @returns {Object} The created node
                 */
                addNode: function(nodeProps) {
                    const node = Templates.createNode(nodeProps);
                    this.graph.nodes.push(node);
                    return node;
                },
                
                /**
                 * Connects two nodes with an edge
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} The created edge
                 */
                addEdge: function(sourceId, targetId) {
                    const edge = Templates.createEdge(sourceId, targetId);
                    this.graph.edges.push(edge);
                    return edge;
                },
                
                /**
                 * Finds a node at the specified coordinates
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @returns {Object|null} Node at coordinates or null if none found
                 */
                findNodeAt: function(x, y) {
                    // Search from front to back (later nodes appear on top)
                    for (let i = this.graph.nodes.length - 1; i >= 0; i--) {
                        const node = this.graph.nodes[i];
                        
                        // Distance from point to node center
                        const dx = x - (node.x + node.size / 2);
                        const dy = y - (node.y + node.size / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // If distance is less than radius, point is inside circle
                        if (distance <= node.size / 2) {
                            return node;
                        }
                    }
                    return null;
                },
                
                /**
                 * Updates node properties
                 * @param {string} nodeId - ID of node to update
                 * @param {Object} changes - Properties to update
                 */
                updateNode: function(nodeId, changes) {
                    const node = this.graph.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    // Apply changes
                    Object.assign(node, changes);
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.updated(node.name));
                },
                
                /**
                 * Exports graph data to specified format
                 * @param {string} format - Format to export ('json', 'csv')
                 */
                exportData: function(format) {
                    if (format === 'json') {
                        ExportManager.toJson();
                    } else if (format === 'csv') {
                        ExportManager.toCsv();
                    }
                }
            };
            
            // =====================================================================
            // DOM: Interface to DOM Elements
            // =====================================================================

            /**
             * DOM: Centralized DOM access
             * 
             * Provides a single interface to all DOM elements used by the application.
             * 
             * @version 1.🪴1.0 - Added tooltip and emoji picker elements
             */
            const DOM = {
                /** Element references */
                elements: {},
                
                /** Canvas element and context */
                canvas: null,
                ctx: null,
                
                /**
                 * Initializes DOM references
                 * Gathers all necessary DOM elements into a single access point
                 */
                init: function() {
                    // Core elements
                    const ids = [
                        'network-canvas', 'add-node-btn', 'export-json-btn', 'export-csv-btn',
                        'node-name', 'node-content', 'update-node-btn', 'editor-title',
                        'editor-subtitle', 'editor-placeholder', 'status', 'node-tooltip',
                        'node-emoji-select', 'emoji-picker', 'emoji-grid'
                    ];
                    
                    // Populate elements object
                    ids.forEach(id => {
                        this.elements[id] = document.getElementById(id);
                    });
                    
                    // Setup canvas and context
                    this.canvas = this.elements['network-canvas'];
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Ensure canvas is properly sized
                    this.resizeCanvas();
                    
                    // Initialize emoji picker
                    this.initEmojiPicker();
                },
                
                /**
                 * Sets the canvas size to match its container
                 */
                resizeCanvas: function() {
                    const container = document.querySelector('.canvas-container');
                    this.canvas.width = container.offsetWidth;
                    this.canvas.height = container.offsetHeight;
                },
                
                /**
                 * Initialize emoji picker with available options
                 */
                initEmojiPicker: function() {
                    const grid = this.elements['emoji-grid'];
                    if (!grid) return;
                    
                    // Clear existing items
                    grid.innerHTML = '';
                    
                    // Add all emojis
                    META.emojiPicker.emojis.forEach(emoji => {
                        const item = document.createElement('div');
                        item.className = 'emoji-item';
                        item.textContent = emoji;
                        item.setAttribute('data-emoji', emoji);
                        item.addEventListener('click', () => {
                            if (State.ui.selectedNode) {
                                // Update the emoji select button
                                this.elements['node-emoji-select'].textContent = emoji;
                                
                                // Hide the picker
                                this.elements['emoji-picker'].classList.remove('active');
                            }
                        });
                        
                        grid.appendChild(item);
                    });
                    
                    // Set up emoji select button
                    const emojiSelect = this.elements['node-emoji-select'];
                    const emojiPicker = this.elements['emoji-picker'];
                    
                    if (emojiSelect && emojiPicker) {
                        emojiSelect.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // Position the picker near the button
                            const rect = emojiSelect.getBoundingClientRect();
                            emojiPicker.style.top = `${rect.bottom + 5}px`;
                            emojiPicker.style.left = `${rect.left}px`;
                            
                            // Toggle visibility
                            emojiPicker.classList.toggle('active');
                        });
                        
                        // Close picker when clicking outside
                        document.addEventListener('click', (e) => {
                            if (!emojiPicker.contains(e.target) && e.target !== emojiSelect) {
                                emojiPicker.classList.remove('active');
                            }
                        });
                    }
                }
            };
            
            // =====================================================================
            // UI: User Interface Management
            // =====================================================================

            /**
             * UI: User interface controller
             * 
             * Handles all updates to the user interface based on application state.
             * 
             * @version 1.🪴1.0 - Updated for emoji node identifiers
             */
            const UI = {
                /**
                 * Updates the node editor with node content
                 * @param {Object|null} node - Node to edit or null to clear editor
                 */
                updateEditor: function(node) {
                    const placeholderEl = DOM.elements['editor-placeholder'];
                    const emojiSelectEl = DOM.elements['node-emoji-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    const titleEl = DOM.elements['editor-title'];
                    const subtitleEl = DOM.elements['editor-subtitle'];
                    const updateBtnEl = DOM.elements['update-node-btn'];
                    const emojiPickerEl = DOM.elements['emoji-picker'];
                    
                    // Hide emoji picker if open
                    if (emojiPickerEl) {
                        emojiPickerEl.classList.remove('active');
                    }
                    
                    if (node) {
                        // Show editor with node content
                        placeholderEl.style.display = 'none';
                        nameEl.style.display = 'block';
                        contentEl.style.display = 'block';
                        updateBtnEl.style.display = 'block';
                        emojiSelectEl.parentElement.parentElement.style.display = 'flex';
                        
                        // Set content
                        emojiSelectEl.textContent = node.emoji;
                        nameEl.value = node.name || '';
                        contentEl.value = node.content || '';
                        
                        // Update headings
                        titleEl.innerHTML = `<span class="node-emoji">${node.emoji}</span> Editing ${node.name || 'Untitled Node'}`;
                        subtitleEl.textContent = 'Make changes and click "Update Node" to save';
                    } else {
                        // Hide editor, show placeholder
                        placeholderEl.style.display = 'flex';
                        nameEl.style.display = 'none';
                        contentEl.style.display = 'none';
                        updateBtnEl.style.display = 'none';
                        emojiSelectEl.parentElement.parentElement.style.display = 'none';
                        
                        // Update headings
                        titleEl.textContent = 'Node Editor';
                        subtitleEl.textContent = 'Select a node to edit its content';
                    }
                },
                
                /**
                 * Show node tooltip at specified position
                 * @param {Object} node - Node to show tooltip for
                 * @param {number} x - X position
                 * @param {number} y - Y position 
                 */
                showNodeTooltip: function(node, x, y) {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    // Set tooltip content and position
                    tooltip.textContent = node.name || 'Untitled Node';
                    tooltip.style.left = `${x}px`;
                    tooltip.style.top = `${y - 30}px`;
                    tooltip.style.opacity = '1';
                    
                    // Update hovered node reference
                    State.ui.hoveredNode = node;
                },
                
                /**
                 * Hide node tooltip
                 */
                hideNodeTooltip: function() {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    tooltip.style.opacity = '0';
                    State.ui.hoveredNode = null;
                },
                
                /**
                 * Updates the status message
                 * @param {string} message - Status message to display
                 * @param {number} [duration=3000] - Duration to show message in ms
                 */
                updateStatus: function(message, duration = 3000) {
                    const statusEl = DOM.elements.status;
                    if (!statusEl) return;
                    
                    // Set message
                    statusEl.textContent = message;
                    Debug.log(`Status: ${message}`);
                    
                    // Clear after duration
                    setTimeout(() => {
                        if (statusEl.textContent === message) {
                            statusEl.textContent = State.ui.selectedNode ? 
                                META.templates.status.selected(State.ui.selectedNode.name || 'Untitled Node') : 
                                META.templates.status.ready;
                        }
                    }, duration);
                }
            };
            
            // =====================================================================
            // RENDERER: Canvas Drawing System
            // =====================================================================

            /**
             * Renderer: Visual drawing system
             * 
             * Handles all drawing operations on the canvas, visualizing
             * the nodes and edges in the network.
             * 
             * @version 1.🪴1.0 - Completely rewritten for circular emoji nodes
             */
            const Renderer = {
                /**
                 * Draws the complete graph
                 * Renders all nodes and edges on the canvas
                 */
                draw: function() {
                    const ctx = DOM.ctx;
                    const canvas = DOM.canvas;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw all edges
                    this.drawEdges();
                    
                    // Draw all nodes
                    this.drawNodes();
                },
                
                /**
                 * Draws all edges in the graph
                 */
                drawEdges: function() {
                    const ctx = DOM.ctx;
                    const edges = State.graph.edges;
                    
                    // Set default edge style
                    ctx.strokeStyle = META.edge.style.color;
                    ctx.lineWidth = META.edge.style.width;
                    
                    edges.forEach(edge => {
                        // Find connected nodes
                        const sourceNode = State.graph.nodes.find(n => n.id === edge.sourceId);
                        const targetNode = State.graph.nodes.find(n => n.id === edge.targetId);
                        
                        // Skip if either node is missing
                        if (!sourceNode || !targetNode) return;
                        
                        // Calculate connection points (center of nodes)
                        const sourceX = sourceNode.x + sourceNode.size / 2;
                        const sourceY = sourceNode.y + sourceNode.size / 2;
                        const targetX = targetNode.x + targetNode.size / 2;
                        const targetY = targetNode.y + targetNode.size / 2;
                        
                        // Draw connecting line
                        ctx.beginPath();
                        ctx.moveTo(sourceX, sourceY);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                    });
                },
                
                /**
                 * Draws all nodes in the graph
                 */
                drawNodes: function() {
                    const nodes = State.graph.nodes;
                    
                    nodes.forEach(node => {
                        this.drawNode(node);
                    });
                },
                
                /**
                 * Draws a single node
                 * @param {Object} node - Node to draw
                 */
                drawNode: function(node) {
                    const ctx = DOM.ctx;
                    const isSelected = node === State.ui.selectedNode;
                    
                    // Calculate center position
                    const centerX = node.x + node.size / 2;
                    const centerY = node.y + node.size / 2;
                    const radius = node.size / 2;
                    
                    // Draw node background circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    // Fill with gradient
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius * 0.7,
                        centerX, centerY, radius
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(1, '#f0f0f0');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw outline, thicker if selected
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#d9d9d9';
                        ctx.lineWidth = 1;
                    }
                    
                    ctx.stroke();
                    
                    // Draw emoji in center
                    ctx.font = `${node.size * 0.4}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.emoji, centerX, centerY);
                }
            };
            
            // =====================================================================
            // INPUT: User Interaction Handler
            // =====================================================================

            /**
             * InputHandler: Interaction management
             * 
             * Handles all user interactions with the application,
             * including mouse events, keyboard input, and button clicks.
             * 
             * @version 1.🪴1.0 - Updated for circular node interactions
             */
            const InputHandler = {
                /**
                 * Sets up all event listeners
                 */
                init: function() {
                    // Canvas mouse events
                    DOM.canvas.addEventListener('mousedown', this.handleMouseDown);
                    DOM.canvas.addEventListener('mousemove', this.handleMouseMove);
                    DOM.canvas.addEventListener('mouseup', this.handleMouseUp);
                    DOM.canvas.addEventListener('click', this.handleClick);
                    
                    // Button events
                    DOM.elements['add-node-btn'].addEventListener('click', this.handleAddNode);
                    DOM.elements['export-json-btn'].addEventListener('click', () => State.exportData('json'));
                    DOM.elements['export-csv-btn'].addEventListener('click', () => State.exportData('csv'));
                    DOM.elements['update-node-btn'].addEventListener('click', this.handleUpdateNode);
                    
                    // Window resize event
                    window.addEventListener('resize', () => {
                        DOM.resizeCanvas();
                        Renderer.draw();
                    });
                },
                
                /**
                 * Handles mouse down event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseDown: function(e) {
                    // Get mouse position relative to canvas
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find node under cursor
                    const node = State.findNodeAt(x, y);
                    
                    if (node) {
                        // Set drag start position
                        State.ui.dragStartX = x;
                        State.ui.dragStartY = y;
                        State.ui.draggedNode = node;
                        
                        // Calculate offset from the top-left corner of the node
                        State.ui.dragOffsetX = x - node.x;
                        State.ui.dragOffsetY = y - node.y;
                        
                        // Don't set isDragging yet - wait for movement threshold
                        
                        // Change cursor
                        DOM.canvas.style.cursor = 'grabbing';
                    }
                },
                
                /**
                 * Handles mouse move event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseMove: function(e) {
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Handle dragging - wait for movement threshold
                    if (State.ui.draggedNode) {
                        // Check if we've moved enough to start dragging
                        const dragDistance = Math.sqrt(
                            Math.pow(x - State.ui.dragStartX, 2) + 
                            Math.pow(y - State.ui.dragStartY, 2)
                        );
                        
                        if (dragDistance >= META.node.dragThreshold || State.ui.isDragging) {
                            // Start dragging if we haven't already
                            State.ui.isDragging = true;
                            
                            // Update node position
                            State.ui.draggedNode.x = x - State.ui.dragOffsetX;
                            State.ui.draggedNode.y = y - State.ui.dragOffsetY;
                            Renderer.draw();
                        }
                    } else {
                        // Check for node hovering for tooltip
                        const hoveredNode = State.findNodeAt(x, y);
                        
                        if (hoveredNode) {
                            // Show tooltip
                            UI.showNodeTooltip(hoveredNode, x, y);
                            // Update cursor
                            DOM.canvas.style.cursor = 'grab';
                        } else {
                            // Hide tooltip
                            UI.hideNodeTooltip();
                            // Reset cursor
                            DOM.canvas.style.cursor = 'default';
                        }
                    }
                },
                
                /**
                 * Handles mouse up event
                 */
                handleMouseUp: function() {
                    // End dragging
                    State.ui.isDragging = false;
                    State.ui.draggedNode = null;
                    
                    // Reset cursor
                    DOM.canvas.style.cursor = 'default';
                },
                
                /**
                 * Handles mouse click event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleClick: function(e) {
                    // Ignore if we were dragging
                    if (State.ui.isDragging) return;
                    
                    // Get mouse position
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find and select node
                    const node = State.findNodeAt(x, y);
                    State.selectNode(node);
                },
                
                /**
                 * Handles adding a new node
                 */
                handleAddNode: function() {
                    // Calculate position for new node
                    const canvas = DOM.canvas;
                    const nodeSize = META.node.defaults.size;
                    const centerX = canvas.width / 2 - nodeSize / 2;
                    const centerY = canvas.height / 2 - nodeSize / 2;
                    
                    // Add offset if there's a selected node
                    let x = centerX;
                    let y = centerY;
                    
                    if (State.ui.selectedNode) {
                        x = State.ui.selectedNode.x + nodeSize * 2;
                        y = State.ui.selectedNode.y;
                        
                        // Create edge from selected to new node
                        const newNode = State.addNode({ x, y });
                        State.addEdge(State.ui.selectedNode.id, newNode.id);
                        State.selectNode(newNode);
                    } else {
                        // Create node at center if no selection
                        const newNode = State.addNode({ 
                            x, y, 
                            emoji: META.templates.welcome.emoji,
                            name: META.templates.welcome.name,
                            content: META.templates.welcome.content
                        });
                        State.selectNode(newNode);
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.created(State.ui.selectedNode.name));
                },
                
                /**
                 * Handles updating a node
                 */
                handleUpdateNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get values from editor
                    const emojiEl = DOM.elements['node-emoji-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    
                    // Update node
                    State.updateNode(State.ui.selectedNode.id, {
                        emoji: emojiEl.textContent,
                        name: nameEl.value,
                        content: contentEl.value
                    });
                    
                    // Update editor title
                    const titleEl = DOM.elements['editor-title'];
                    titleEl.innerHTML = `<span class="node-emoji">${emojiEl.textContent}</span> Editing ${nameEl.value || 'Untitled Node'}`;
                }
            };
            
            // =====================================================================
            // EXPORT: Data Export Functionality
            // =====================================================================

            /**
             * ExportManager: Data export system
             * 
             * Handles exporting graph data to different formats.
             * 
             * @version 1.🪴1.0 - Updated for new node structure
             */
            const ExportManager = {
                /**
                 * Exports graph to JSON
                 */
                toJson: function() {
                    // Create a copy of the graph data
                    const graphData = JSON.stringify(State.graph, null, 2);
                    
                    // Download as file
                    this.downloadFile(graphData, 'nodepad.json', META.export.formats.json.contentType);
                    UI.updateStatus(META.templates.status.exported('JSON'));
                },
                
                /**
                 * Exports graph to CSV files
                 */
                toCsv: function() {
                    // Create nodes CSV
                    const nodeHeader = 'id,emoji,name,content,x,y,size\n';
                    const nodeRows = State.graph.nodes.map(node => {
                        // Escape content for CSV
                        const escapedContent = `"${node.content.replace(/"/g, '""')}"`;
                        const escapedName = `"${(node.name || '').replace(/"/g, '""')}"`;
                        const escapedEmoji = `"${node.emoji}"`;
                        
                        return `${node.id},${escapedEmoji},${escapedName},${escapedContent},${node.x},${node.y},${node.size}`;
                    }).join('\n');
                    
                    const nodesCSV = nodeHeader + nodeRows;
                    
                    // Create edges CSV
                    const edgeHeader = 'id,sourceId,targetId\n';
                    const edgeRows = State.graph.edges.map(edge => {
                        return `${edge.id},${edge.sourceId},${edge.targetId}`;
                    }).join('\n');
                    
                    const edgesCSV = edgeHeader + edgeRows;
                    
                    // Download both files
                    this.downloadFile(nodesCSV, META.export.formats.nodeCsv.filename, META.export.formats.nodeCsv.contentType);
                    this.downloadFile(edgesCSV, META.export.formats.edgeCsv.filename, META.export.formats.edgeCsv.contentType);
                    
                    UI.updateStatus(META.templates.status.exported('CSV'));
                },
                
                /**
                 * Creates and triggers download for a file
                 * @param {string} content - File content
                 * @param {string} fileName - File name
                 * @param {string} contentType - File MIME type
                 */
                downloadFile: function(content, fileName, contentType) {
                    // Create blob and download link
                    const blob = new Blob([content], { type: contentType });
                    const url = URL.createObjectURL(blob);
                    
                    // Create and trigger download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    
                    // Cleanup
                    URL.revokeObjectURL(url);
                }
            };
            
            // =====================================================================
            // DEBUG: Debugging Utilities
            // =====================================================================

            /**
             * Debug: Debugging toolkit
             * 
             * Provides consistent debugging output and error handling.
             * 
             * @version 1.🪴1.0 - Maintained from previous version
             */
            const Debug = {
                /**
                 * Logs a debug message
                 * @param {string} message - Message to log
                 * @param {string} [level='info'] - Log level
                 */
                log: function(message, level = 'info') {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels[level] || META.debug.levels.info;
                    console.log(`${emoji} ${prefix} v${META.version.number}: ${message}`);
                },
                
                /**
                 * Logs an error message
                 * @param {string} message - Error message
                 * @param {Error} [error] - Error object
                 */
                error: function(message, error) {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels.error;
                    console.error(`${emoji} ${prefix} v${META.version.number}: ${message}`, error || '');
                },
                
                /**
                 * Logs a success message
                 * @param {string} message - Success message
                 */
                success: function(message) {
                    this.log(message, 'success');
                }
            };
            
            // =====================================================================
            // APP: Application Initialization
            // =====================================================================

            /**
             * App: Main application controller
             * 
             * Handles the initialization and startup of the application.
             * 
             * @version 1.🪴1.0 - Maintained from previous version
             */
            const App = {
                /**
                 * Initializes the application
                 */
                init: function() {
                    // Initialize DOM references
                    DOM.init();
                    
                    // Set up event handlers
                    InputHandler.init();
                    
                    // Create initial node if no nodes exist
                    if (State.graph.nodes.length === 0) {
                        InputHandler.handleAddNode();
                    }
                    
                    // Render initial state
                    Renderer.draw();
                    
                    Debug.success('Application initialized');
                    UI.updateStatus(`Welcome to NodePad v${META.version.number}!`);
                    
                    return this;
                }
            };
            
            // =====================================================================
            // Initialize the application when DOM is loaded
            // =====================================================================
            
            // Start the application
            App.init();
        });
    </script>
</body>
</html>