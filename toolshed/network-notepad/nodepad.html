<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodePad v1.🌱1.0</title>
    <!-- 
        🔬 MICROSCOPE: SOURCE EXPLORER SYSTEM
        
        Version History:
        v0.0.1 - Initial implementation with popup editor and basic node display
        v0.0.2 - Attempted to refactor with Node class architecture (contained bugs)
        v0.0.3 - Fixed edge rendering bug and simplified architecture
        v0.0.4 - Restructured code with proper DocTrellis versioning and modularized components
        v0.0.5 - Fixed node interaction bug with dragging different nodes
        v0.0.6 - Implemented template-based node rendering system
        v0.0.7 - Added ability to edit node names
        v0.1.0 - First minor version with stable core features and cleaned documentation
        v1.0.0 - Complete constructivist rewrite with knot-compacted architecture
        v1.🌱1.0 - Tentative source explorer feature using browser tabs (experimental)
        
        DocTrellis Feature Status:
        🌱 Core Architecture - Seedling - Constructivist template system with metadata-driven design
        🌱 Node Management - Seedling - Create, select, edit, and drag nodes
        🌱 Edge Connections - Seedling - Connections between nodes
        🌱 Network View - Seedling - Canvas-based visualization
        🌱 Export/Import - Seedling - JSON and CSV export functionality
        🌱 Source Explorer - Seedling - Browser-based source code exploration
    -->
    <style>
        /* 🧠 META System: Constructivist CSS Architecture
           
           This styling system is built as a self-teaching knowledge structure.
           Variables aren't just for consistency - they're organized to reveal
           relationships between values.
           
           For example, spacing follows mathematical relationships:
           - We define a base unit (--space-unit: 8px)
           - Other spaces are multiples/fractions of this unit
           - Comments show the calculated values to aid understanding
           
           This helps developers build a mental model of the design system
           simply by reading the code.
        */
        
        /* Base Variables - Single Source of Truth */
        :root {
            /* Color Palette */
            --color-bg: #fafafa;
            --color-surface: #ffffff;
            --color-surface-alt: #f5f5f5;
            --color-border: #dddddd;
            --color-text: #333333;
            --color-text-muted: #666666;
            --color-primary: #1890ff;
            --color-primary-dark: #096dd9;
            --color-success: #52c41a;
            --color-warning: #faad14;
            --color-error: #f5222d;
            
            /* Spacing System */
            --space-unit: 8px;
            --space-xs: calc(var(--space-unit) * 0.5);  /* 4px */
            --space-sm: var(--space-unit);              /* 8px */
            --space-md: calc(var(--space-unit) * 2);    /* 16px */
            --space-lg: calc(var(--space-unit) * 3);    /* 24px */
            --space-xl: calc(var(--space-unit) * 4);    /* 32px */
            
            /* Typography */
            --font-family: Arial, sans-serif;
            --font-size-base: 14px;
            --font-size-sm: 12px;
            --font-size-lg: 16px;
            --font-weight-normal: 400;
            --font-weight-bold: 600;
            --line-height: 1.6;
            
            /* Layout */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            
            /* Node Dimensions */
            --node-min-width: 150px;
            --node-min-height: 120px;
            --node-header-height: 30px;
        }
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            color: var(--color-text);
            background-color: var(--color-bg);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* 🌱 Application Layout */
        .header {
            background-color: var(--color-surface);
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            margin: 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .version {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            font-weight: var(--font-weight-normal);
            margin-left: var(--space-sm);
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--color-bg);
        }
        
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .editor-container {
            width: 40%;
            display: flex;
            flex-direction: column;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            overflow: hidden;
        }
        
        /* 🌱 Controls */
        .controls {
            display: flex;
            gap: var(--space-sm);
        }
        
        button {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-surface-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: var(--font-size-base);
            transition: background-color var(--transition-fast);
        }
        
        button:hover {
            background-color: var(--color-border);
        }
        
        button:active {
            background-color: var(--color-border);
        }
        
        button.primary {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        button.primary:hover {
            background-color: var(--color-primary-dark);
        }
        
        /* 🧠 Editor Styles */
        .editor-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface-alt);
        }
        
        .editor-title {
            margin: 0 0 var(--space-xs) 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
        }
        
        .editor-subtitle {
            color: var(--color-text-muted);
            font-size: var(--font-size-base);
            margin: 0;
        }
        
        .editor-content {
            flex: 1;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-placeholder {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-muted);
            font-style: italic;
            text-align: center;
            padding: var(--space-lg);
        }
        
        .name-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        #node-name {
            width: 100%;
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            margin-bottom: var(--space-md);
            transition: border-color var(--transition-fast);
        }
        
        #node-name:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        #node-content {
            flex: 1;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            resize: none;
            margin-bottom: var(--space-md);
        }
        
        #node-content:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        .editor-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .size-controls {
            display: flex;
            gap: var(--space-md);
        }
        
        .dimension-control {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }
        
        .dimension-label {
            display: flex;
            align-items: center;
            font-size: var(--font-size-lg);
            margin-right: var(--space-xs);
        }
        
        .size-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-size-lg);
        }
        
        /* 🔬 Source Explorer Style */
        .emoji-explorer {
            cursor: pointer;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform var(--transition-fast);
        }
        
        .emoji-explorer:hover {
            transform: scale(1.2);
        }
        
        .emoji-explorer::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: var(--space-xs) var(--space-sm);
            background-color: var(--color-text);
            color: white;
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-sm);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--transition-fast);
            z-index: 10;
        }
        
        .emoji-explorer:hover::after {
            opacity: 1;
        }
        
        /* 🛠️ Status Indicator */
        .status {
            position: absolute;
            bottom: var(--space-sm);
            left: var(--space-sm);
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-base);
            color: var(--color-text-muted);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">
            <span class="emoji-explorer" data-tooltip="NodePad: Nonlinear Knowledge Network">📝</span> 
            NodePad <span class="version">v1.🌱1.0</span>
        </h1>
        <div class="controls">
            <button id="add-node-btn">
                <span class="emoji-explorer" data-tooltip="Create a new connected node">🌱</span> Add Node
            </button>
            <button id="export-json-btn">
                <span class="emoji-explorer" data-tooltip="Save as JSON file">📤</span> Export JSON
            </button>
            <button id="export-csv-btn">
                <span class="emoji-explorer" data-tooltip="Save as CSV files">📤</span> Export CSVs
            </button>
            <button id="help-btn">
                <span class="emoji-explorer" data-tooltip="Learn about Source Explorer">🔬</span> Source Explorer
            </button>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Network View (Left Side) -->
        <div class="canvas-container">
            <canvas id="network-canvas"></canvas>
            <div class="status" id="status">Ready</div>
        </div>
        
        <!-- Node Editor (Right Side) -->
        <div class="editor-container">
            <div class="editor-header">
                <h2 class="editor-title" id="editor-title">Node Editor</h2>
                <p class="editor-subtitle" id="editor-subtitle">Select a node to edit its content</p>
            </div>
            
            <div class="editor-content" id="editor-content">
                <div class="editor-placeholder" id="editor-placeholder">
                    Click on a node in the network view to edit its content
                </div>
                
                <label class="name-label" for="node-name">Node Name:</label>
                <input type="text" id="node-name" placeholder="Enter a name for this node">
                
                <textarea id="node-content" placeholder="Enter your notes here..."></textarea>
                
                <div class="editor-actions">
                    <div class="size-controls">
                        <div class="dimension-control">
                            <span class="emoji-explorer dimension-label" data-tooltip="Adjust node height">↕️</span>
                            <button class="size-btn" id="height-decrease">-</button>
                            <button class="size-btn" id="height-increase">+</button>
                        </div>
                        <div class="dimension-control">
                            <span class="emoji-explorer dimension-label" data-tooltip="Adjust node width">↔️</span>
                            <button class="size-btn" id="width-decrease">-</button>
                            <button class="size-btn" id="width-increase">+</button>
                        </div>
                        <div class="dimension-control">
                            <span class="emoji-explorer dimension-label" data-tooltip="Change node style">🎨</span>
                            <button class="size-btn" id="toggle-style">↺</button>
                        </div>
                    </div>
                    <button id="update-node-btn" class="primary">Update Node</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * 🔬 NodePad v1.🌱1.0: A Constructivist Knowledge Network
         * 
         * This application embodies constructivist programming principles:
         * - Code as a learning artifact (self-documenting and explorable)
         * - Learning through construction (interactive exploration of implementation)
         * - Explicit over implicit patterns (metadata-driven architecture)
         * 
         * The Source Explorer feature transforms every emoji into a knowledge portal
         * that opens a new browser tab with the relevant source code section.
         * 
         * @author Constructivist Programming Team
         * @version 1.🌱1.0
         */
        
        document.addEventListener('DOMContentLoaded', function() {
            // =====================================================================
            // 🧠 META-SYSTEM: Application Metadata and Configuration
            // =====================================================================

            /**
             * 🧠 META: Application knowledge system
             * 
             * This object serves as a single source of truth for all application
             * configuration, providing a centralized knowledge structure that reveals
             * the relationships between all configurable parameters.
             * 
             * By unifying configuration in one self-documenting structure, we make
             * the system easier to understand, maintain, and extend.
             */
            const META = {
                /** Application version information */
                version: {
                    number: '1.🌱1.0',
                    name: 'Source Explorer Edition',
                    date: '2025-03-31'
                },
                
                /** Debug configuration */
                debug: {
                    enabled: true,
                    prefix: '🐛 NodePad',
                    levels: {
                        info: '📘',
                        warn: '⚠️',
                        error: '❌',
                        success: '✅'
                    }
                },
                
                /** Node configuration */
                node: {
                    defaults: {
                        width: 250,
                        height: 200,
                        style: 'standard',
                        content: ''
                    },
                    constraints: {
                        minWidth: 150,
                        minHeight: 120,
                        maxWidth: 500,
                        maxHeight: 400,
                        resizeStep: 20
                    },
                    rendering: {
                        headerHeight: 30,
                        textPadding: 15,
                        lineHeight: 20,
                        borderRadius: 4
                    }
                },
                
                /** Available node rendering styles */
                nodeStyles: {
                    standard: {
                        id: 'standard',
                        name: 'Standard',
                        colors: {
                            background: '#ffffff',
                            selectedBackground: '#e6f7ff',
                            header: '#f5f5f5',
                            selectedHeader: '#bae7ff',
                            border: '#d9d9d9',
                            selectedBorder: '#1890ff',
                            text: '#000000'
                        }
                    },
                    minimal: {
                        id: 'minimal',
                        name: 'Minimal',
                        colors: {
                            background: '#f8f9fa',
                            selectedBackground: '#e3f2fd',
                            header: '#edf2f7',
                            selectedHeader: '#bbdefb',
                            border: '#cbd5e0',
                            selectedBorder: '#64b5f6',
                            text: '#1a202c'
                        }
                    }
                },
                
                /** Edge configuration */
                edge: {
                    style: {
                        color: '#d9d9d9',
                        width: 1,
                        selectedColor: '#1890ff',
                        selectedWidth: 2
                    }
                },
                
                /** Export configuration */
                export: {
                    formats: {
                        json: {
                            extension: 'json',
                            contentType: 'application/json'
                        },
                        nodeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-nodes.csv'
                        },
                        edgeCsv: {
                            extension: 'csv',
                            contentType: 'text/csv',
                            filename: 'nodepad-edges.csv'
                        }
                    }
                },
                
                /** Source Explorer configuration */
                sourceExplorer: {
                    enabled: true,
                    selector: '.emoji-explorer',
                    helpMessage: 'Click any emoji to explore its source code in a new tab'
                },
                
                /** Templates for static text */
                templates: {
                    welcome: {
                        nodeName: 'Welcome Note',
                        nodeContent: 'Welcome to NodePad!\n\nThis is a space for your interconnected thoughts and ideas.\n\n• Click nodes to edit their content\n• Drag nodes to rearrange them\n• Connect nodes to show relationships\n• Use the controls to customize nodes\n• Click any emoji to explore the source code in a new tab\n\nStart organizing your knowledge network!'
                    },
                    status: {
                        ready: 'Ready',
                        selected: nodeId => `Selected: ${nodeId}`,
                        created: nodeId => `Created node: ${nodeId}`,
                        updated: nodeId => `Updated: ${nodeId}`,
                        exported: format => `Exported ${format} file`,
                        resized: dimension => `Resized ${dimension}`
                    }
                }
            };
            
            // =====================================================================
            // 🧩 TEMPLATES: Reusable Object Factories
            // =====================================================================

            /**
             * 🧩 Templates: Object factory system
             * 
             * Instead of having object creation spread throughout the code, we
             * centralize the creation of all major objects through this template
             * system. This ensures consistency and makes it easier to understand
             * the structure of data in the application.
             * 
             * Think of these as "cookie cutters" that ensure every object
             * has the expected properties and follows the same pattern.
             */
            const Templates = {
                /**
                 * Creates a new node with specified properties
                 * @param {Object} props - Properties to override defaults
                 * @returns {Object} A new node object
                 */
                createNode: function(props = {}) {
                    const id = props.id || `node-${State.counters.nextNodeId++}`;
                    
                    return {
                        id: id,
                        name: props.name || '',
                        content: props.content || META.node.defaults.content,
                        x: props.x || 0,
                        y: props.y || 0,
                        width: props.width || META.node.defaults.width,
                        height: props.height || META.node.defaults.height,
                        style: props.style || META.node.defaults.style
                    };
                },
                
                /**
                 * Creates a new edge between two nodes
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} A new edge object
                 */
                createEdge: function(sourceId, targetId) {
                    return {
                        id: `edge-${State.counters.nextEdgeId++}`,
                        sourceId: sourceId,
                        targetId: targetId
                    };
                }
            };
            
            // =====================================================================
            // 🧠 STATE: Global Application State
            // =====================================================================

            /**
             * 🧠 State: Global application state management
             * 
             * This object centralizes all the application's changeable data in one
             * place, making it easier to understand, track, and debug the current
             * state of the system.
             * 
             * By keeping all state in one place, we avoid hidden state that would
             * make the system harder to understand and maintain.
             */
            const State = {
                /** Graph data containing nodes and edges */
                graph: {
                    nodes: [],
                    edges: []
                },
                
                /** UI state information */
                ui: {
                    selectedNode: null,
                    isDragging: false,
                    draggedNode: null,
                    dragOffsetX: 0,
                    dragOffsetY: 0
                },
                
                /** Global counters */
                counters: {
                    nextNodeId: 1,
                    nextEdgeId: 1
                },
                
                /**
                 * Selects a node and updates UI accordingly
                 * @param {Object|null} node - Node to select or null to deselect
                 */
                selectNode: function(node) {
                    this.ui.selectedNode = node;
                    UI.updateEditor(node);
                    Renderer.draw();
                    
                    if (node) {
                        UI.updateStatus(META.templates.status.selected(node.name || node.id));
                    } else {
                        UI.updateStatus(META.templates.status.ready);
                    }
                },
                
                /**
                 * Adds a new node to the graph
                 * @param {Object} nodeProps - Properties for the new node
                 * @returns {Object} The created node
                 */
                addNode: function(nodeProps) {
                    const node = Templates.createNode(nodeProps);
                    this.graph.nodes.push(node);
                    return node;
                },
                
                /**
                 * Connects two nodes with an edge
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} The created edge
                 */
                addEdge: function(sourceId, targetId) {
                    const edge = Templates.createEdge(sourceId, targetId);
                    this.graph.edges.push(edge);
                    return edge;
                },
                
                /**
                 * Finds a node at the specified coordinates
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @returns {Object|null} Node at coordinates or null if none found
                 */
                findNodeAt: function(x, y) {
                    // Search from front to back (later nodes appear on top)
                    for (let i = this.graph.nodes.length - 1; i >= 0; i--) {
                        const node = this.graph.nodes[i];
                        if (x >= node.x && x <= node.x + node.width &&
                            y >= node.y && y <= node.y + node.height) {
                            return node;
                        }
                    }
                    return null;
                },
                
                /**
                 * Updates node content and name
                 * @param {string} nodeId - ID of node to update
                 * @param {Object} changes - Properties to update
                 */
                updateNode: function(nodeId, changes) {
                    const node = this.graph.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    // Apply changes
                    Object.assign(node, changes);
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.updated(node.name || node.id));
                },
                
                /**
                 * Exports graph data to specified format
                 * @param {string} format - Format to export ('json', 'csv')
                 */
                exportData: function(format) {
                    if (format === 'json') {
                        ExportManager.toJson();
                    } else if (format === 'csv') {
                        ExportManager.toCsv();
                    }
                }
            };
            
            // =====================================================================
            // 🛠️ DOM: Interface to DOM Elements
            // =====================================================================

            /**
             * 🛠️ DOM: Centralized DOM access
             * 
             * This module provides a single interface to all DOM elements used
             * by the application. This makes it easier to find where elements
             * are accessed and ensures consistent access patterns.
             * 
             * Instead of using document.getElementById() throughout the code,
             * we gather all references in one place for better maintainability.
             */
            const DOM = {
                /** Element references */
                elements: {},
                
                /** Canvas element and context */
                canvas: null,
                ctx: null,
                
                /**
                 * Initializes DOM references
                 * Gathers all necessary DOM elements into a single access point
                 */
                init: function() {
                    // Core elements
                    const ids = [
                        'network-canvas', 'add-node-btn', 'export-json-btn', 'export-csv-btn',
                        'node-name', 'node-content', 'update-node-btn', 'editor-title',
                        'editor-subtitle', 'editor-placeholder', 'status',
                        'height-decrease', 'height-increase', 'width-decrease', 'width-increase',
                        'toggle-style', 'help-btn'
                    ];
                    
                    // Populate elements object
                    ids.forEach(id => {
                        this.elements[id] = document.getElementById(id);
                    });
                    
                    // Setup canvas and context
                    this.canvas = this.elements['network-canvas'];
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Ensure canvas is properly sized
                    this.resizeCanvas();
                    
                    // Initialize source explorer
                    SourceExplorer.init();
                },
                
                /**
                 * Sets the canvas size to match its container
                 */
                resizeCanvas: function() {
                    const container = document.querySelector('.canvas-container');
                    this.canvas.width = container.offsetWidth;
                    this.canvas.height = container.offsetHeight;
                }
            };
            
            // =====================================================================
            // 🎨 UI: User Interface Management
            // =====================================================================

            /**
             * 🎨 UI: User interface controller
             * 
             * This module handles all updates to the user interface based on the
             * current application state. It acts as a rendering layer between
             * the state and the DOM.
             * 
             * By centralizing UI updates, we ensure consistent presentation and
             * easier maintenance.
             */
            const UI = {
                /**
                 * Updates the node editor with node content
                 * @param {Object|null} node - Node to edit or null to clear editor
                 */
                updateEditor: function(node) {
                    const placeholderEl = DOM.elements['editor-placeholder'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    const titleEl = DOM.elements['editor-title'];
                    const subtitleEl = DOM.elements['editor-subtitle'];
                    const updateBtnEl = DOM.elements['update-node-btn'];
                    const controls = document.querySelectorAll('.dimension-control');
                    
                    if (node) {
                        // Show editor with node content
                        placeholderEl.style.display = 'none';
                        nameEl.style.display = 'block';
                        contentEl.style.display = 'block';
                        updateBtnEl.style.display = 'block';
                        
                        // Set content
                        nameEl.value = node.name || '';
                        contentEl.value = node.content || '';
                        
                        // Update headings
                        titleEl.textContent = `Editing ${node.name || node.id}`;
                        subtitleEl.textContent = 'Make changes and click "Update Node" to save';
                        
                        // Show controls
                        controls.forEach(c => c.style.display = 'flex');
                    } else {
                        // Hide editor, show placeholder
                        placeholderEl.style.display = 'flex';
                        nameEl.style.display = 'none';
                        contentEl.style.display = 'none';
                        updateBtnEl.style.display = 'none';
                        
                        // Update headings
                        titleEl.textContent = 'Node Editor';
                        subtitleEl.textContent = 'Select a node to edit its content';
                        
                        // Hide controls
                        controls.forEach(c => c.style.display = 'none');
                    }
                },
                
                /**
                 * Updates the status message
                 * @param {string} message - Status message to display
                 * @param {number} [duration=3000] - Duration to show message in ms
                 */
                updateStatus: function(message, duration = 3000) {
                    const statusEl = DOM.elements.status;
                    if (!statusEl) return;
                    
                    // Set message
                    statusEl.textContent = message;
                    Debug.log(`Status: ${message}`);
                    
                    // Clear after duration
                    setTimeout(() => {
                        if (statusEl.textContent === message) {
                            statusEl.textContent = State.ui.selectedNode ? 
                                META.templates.status.selected(State.ui.selectedNode.name || State.ui.selectedNode.id) : 
                                META.templates.status.ready;
                        }
                    }, duration);
                }
            };
            
            // =====================================================================
            // 🎨 RENDERER: Canvas Drawing System
            // =====================================================================

            /**
             * 🎨 Renderer: Visual drawing system
             * 
             * This module handles all drawing operations on the canvas, visualizing
             * the nodes and edges in the network. It translates the abstract data
             * model into a concrete visual representation.
             * 
             * By separating rendering logic from state and interaction logic,
             * we make the code easier to understand and maintain.
             */
            const Renderer = {
                /**
                 * Draws the complete graph
                 * Renders all nodes and edges on the canvas
                 */
                draw: function() {
                    const ctx = DOM.ctx;
                    const canvas = DOM.canvas;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw all edges
                    this.drawEdges();
                    
                    // Draw all nodes
                    this.drawNodes();
                },
                
                /**
                 * Draws all edges in the graph
                 */
                drawEdges: function() {
                    const ctx = DOM.ctx;
                    const edges = State.graph.edges;
                    
                    // Set default edge style
                    ctx.strokeStyle = META.edge.style.color;
                    ctx.lineWidth = META.edge.style.width;
                    
                    edges.forEach(edge => {
                        // Find connected nodes
                        const sourceNode = State.graph.nodes.find(n => n.id === edge.sourceId);
                        const targetNode = State.graph.nodes.find(n => n.id === edge.targetId);
                        
                        // Skip if either node is missing
                        if (!sourceNode || !targetNode) return;
                        
                        // Calculate connection points (center of nodes)
                        const sourceX = sourceNode.x + sourceNode.width / 2;
                        const sourceY = sourceNode.y + sourceNode.height / 2;
                        const targetX = targetNode.x + targetNode.width / 2;
                        const targetY = targetNode.y + targetNode.height / 2;
                        
                        // Draw connecting line
                        ctx.beginPath();
                        ctx.moveTo(sourceX, sourceY);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                    });
                },
                
                /**
                 * Draws all nodes in the graph
                 */
                drawNodes: function() {
                    const nodes = State.graph.nodes;
                    
                    nodes.forEach(node => {
                        this.drawNode(node);
                    });
                },
                
                /**
                 * Draws a single node
                 * @param {Object} node - Node to draw
                 */
                drawNode: function(node) {
                    const ctx = DOM.ctx;
                    const isSelected = node === State.ui.selectedNode;
                    const styleTemplate = META.nodeStyles[node.style] || META.nodeStyles.standard;
                    const colors = styleTemplate.colors;
                    const headerHeight = META.node.rendering.headerHeight;
                    const textPadding = META.node.rendering.textPadding;
                    const lineHeight = META.node.rendering.lineHeight;
                    const borderRadius = META.node.rendering.borderRadius;
                    
                    // Set up shadow for depth
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    // Fill and stroke settings based on selection state
                    ctx.fillStyle = isSelected ? colors.selectedBackground : colors.background;
                    ctx.strokeStyle = isSelected ? colors.selectedBorder : colors.border;
                    ctx.lineWidth = isSelected ? 2 : 1;
                    
                    // Draw main rectangle with rounded corners
                    ctx.beginPath();
                    this.roundRect(ctx, node.x, node.y, node.width, node.height, borderRadius);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Reset shadow for other elements
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Draw header background
                    ctx.fillStyle = isSelected ? colors.selectedHeader : colors.header;
                    ctx.beginPath();
                    this.roundRect(ctx, node.x, node.y, node.width, headerHeight, 
                                   [borderRadius, borderRadius, 0, 0]);
                    ctx.fill();
                    
                    // Draw header separator line
                    ctx.strokeStyle = isSelected ? colors.selectedBorder : colors.border;
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y + headerHeight);
                    ctx.lineTo(node.x + node.width, node.y + headerHeight);
                    ctx.stroke();
                    
                    // Draw node name or ID in header
                    ctx.fillStyle = colors.text;
                    ctx.font = `bold 14px var(--font-family)`;
                    const displayName = node.name || node.id;
                    ctx.fillText(displayName, node.x + textPadding, node.y + headerHeight - 10);
                    
                    // Draw content with word wrapping
                    ctx.font = `14px var(--font-family)`;
                    
                    // Get wrapped text lines
                    const maxWidth = node.width - (textPadding * 2);
                    const wrappedText = this.wrapText(ctx, node.content, maxWidth);
                    
                    // Draw each line of text
                    wrappedText.forEach((line, index) => {
                        const y = node.y + headerHeight + textPadding + (index * lineHeight);
                        // Only draw if within node bounds
                        if (y < node.y + node.height - textPadding) {
                            ctx.fillText(line, node.x + textPadding, y);
                        }
                    });
                    
                    // Indicate if content is truncated
                    const contentHeight = wrappedText.length * lineHeight;
                    const maxVisibleHeight = node.height - headerHeight - (textPadding * 2);
                    
                    if (contentHeight > maxVisibleHeight) {
                        ctx.fillStyle = '#999999';
                        ctx.fillText('...', node.x + textPadding, node.y + node.height - textPadding);
                    }
                    
                    // Draw edit indicator if selected
                    if (isSelected) {
                        ctx.fillStyle = colors.selectedBorder;
                        ctx.font = '12px var(--font-family)';
                        ctx.fillText('✎ Edit', node.x + node.width - 40, node.y + node.height - 10);
                    }
                },
                
                /**
                 * Draws a rounded rectangle
                 * @param {CanvasRenderingContext2D} ctx - Canvas context
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @param {number} width - Rectangle width
                 * @param {number} height - Rectangle height
                 * @param {number|Array} radius - Corner radius or array of corner radii
                 */
                roundRect: function(ctx, x, y, width, height, radius) {
                    // Handle different radius specifications
                    if (typeof radius === 'number') {
                        radius = {tl: radius, tr: radius, br: radius, bl: radius};
                    } else if (Array.isArray(radius)) {
                        const [tl, tr, br, bl] = [...radius, ...Array(4-radius.length).fill(0)];
                        radius = {tl, tr, br, bl};
                    } else {
                        radius = {tl: 0, tr: 0, br: 0, bl: 0};
                    }
                    
                    // Draw rounded rectangle path
                    ctx.beginPath();
                    ctx.moveTo(x + radius.tl, y);
                    ctx.lineTo(x + width - radius.tr, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                    ctx.lineTo(x + width, y + height - radius.br);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                    ctx.lineTo(x + radius.bl, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                    ctx.lineTo(x, y + radius.tl);
                    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
                    ctx.closePath();
                },
                
                /**
                 * Wraps text to fit within a specified width
                 * @param {CanvasRenderingContext2D} ctx - Canvas context
                 * @param {string} text - Text to wrap
                 * @param {number} maxWidth - Maximum width for the text
                 * @returns {Array} Array of text lines
                 */
                wrapText: function(ctx, text, maxWidth) {
                    if (!text) return [];
                    
                    const lines = [];
                    
                    // Handle multi-paragraph text
                    const paragraphs = text.split('\n');
                    
                    paragraphs.forEach(paragraph => {
                        // Add empty line for empty paragraphs
                        if (paragraph === '') {
                            lines.push('');
                            return;
                        }
                        
                        // Split paragraph into words
                        const words = paragraph.split(' ');
                        let currentLine = '';
                        
                        // Process each word
                        words.forEach(word => {
                            // Try adding the word to the current line
                            const testLine = currentLine ? currentLine + ' ' + word : word;
                            const metrics = ctx.measureText(testLine);
                            
                            // If the line becomes too long, start a new one
                            if (metrics.width > maxWidth && currentLine !== '') {
                                lines.push(currentLine);
                                currentLine = word;
                            } else {
                                currentLine = testLine;
                            }
                        });
                        
                        // Add the last line
                        if (currentLine) {
                            lines.push(currentLine);
                        }
                    });
                    
                    return lines;
                }
            };
            
            // =====================================================================
            // 🧭 INPUT: User Interaction Handler
            // =====================================================================

            /**
             * 🧭 InputHandler: Interaction management
             * 
             * This module handles all user interactions with the application,
             * including mouse events, keyboard input, and button clicks.
             * 
             * By centralizing input handling, we make it easier to understand
             * how users interact with the system and how these interactions
             * affect the application state.
             */
            const InputHandler = {
                /**
                 * Sets up all event listeners
                 */
                init: function() {
                    // Canvas mouse events
                    DOM.canvas.addEventListener('mousedown', this.handleMouseDown);
                    DOM.canvas.addEventListener('mousemove', this.handleMouseMove);
                    DOM.canvas.addEventListener('mouseup', this.handleMouseUp);
                    DOM.canvas.addEventListener('click', this.handleClick);
                    
                    // Button events
                    DOM.elements['add-node-btn'].addEventListener('click', this.handleAddNode);
                    DOM.elements['export-json-btn'].addEventListener('click', () => State.exportData('json'));
                    DOM.elements['export-csv-btn'].addEventListener('click', () => State.exportData('csv'));
                    DOM.elements['update-node-btn'].addEventListener('click', this.handleUpdateNode);
                    DOM.elements['help-btn'].addEventListener('click', SourceExplorer.showHelp);
                    
                    // Node resize controls
                    DOM.elements['height-decrease'].addEventListener('click', () => this.handleResizeNode('height', -META.node.constraints.resizeStep));
                    DOM.elements['height-increase'].addEventListener('click', () => this.handleResizeNode('height', META.node.constraints.resizeStep));
                    DOM.elements['width-decrease'].addEventListener('click', () => this.handleResizeNode('width', -META.node.constraints.resizeStep));
                    DOM.elements['width-increase'].addEventListener('click', () => this.handleResizeNode('width', META.node.constraints.resizeStep));
                    DOM.elements['toggle-style'].addEventListener('click', this.handleToggleStyle);
                    
                    // Window resize event
                    window.addEventListener('resize', () => {
                        DOM.resizeCanvas();
                        Renderer.draw();
                    });
                },
                
                /**
                 * Handles mouse down event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseDown: function(e) {
                    // Get mouse position relative to canvas
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find node under cursor
                    const node = State.findNodeAt(x, y);
                    
                    if (node) {
                        // Start dragging
                        State.ui.isDragging = true;
                        State.ui.draggedNode = node;
                        State.ui.dragOffsetX = x - node.x;
                        State.ui.dragOffsetY = y - node.y;
                        
                        // Change cursor
                        DOM.canvas.style.cursor = 'grabbing';
                    }
                },
                
                /**
                 * Handles mouse move event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseMove: function(e) {
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Handle dragging
                    if (State.ui.isDragging && State.ui.draggedNode) {
                        // Update node position
                        State.ui.draggedNode.x = x - State.ui.dragOffsetX;
                        State.ui.draggedNode.y = y - State.ui.dragOffsetY;
                        Renderer.draw();
                    } else {
                        // Update cursor style based on hover
                        const node = State.findNodeAt(x, y);
                        DOM.canvas.style.cursor = node ? 'grab' : 'default';
                    }
                },
                
                /**
                 * Handles mouse up event
                 */
                handleMouseUp: function() {
                    // End dragging
                    State.ui.isDragging = false;
                    State.ui.draggedNode = null;
                    
                    // Reset cursor
                    DOM.canvas.style.cursor = 'default';
                },
                
                /**
                 * Handles mouse click event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleClick: function(e) {
                    // Ignore if we just finished dragging
                    if (State.ui.isDragging) return;
                    
                    // Get mouse position
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find and select node
                    const node = State.findNodeAt(x, y);
                    State.selectNode(node);
                },
                
                /**
                 * Handles adding a new node
                 */
                handleAddNode: function() {
                    // Calculate position for new node
                    const canvas = DOM.canvas;
                    const centerX = canvas.width / 2 - META.node.defaults.width / 2;
                    const centerY = canvas.height / 2 - META.node.defaults.height / 2;
                    
                    // Add offset if there's a selected node
                    let x = centerX;
                    let y = centerY;
                    
                    if (State.ui.selectedNode) {
                        x = State.ui.selectedNode.x + State.ui.selectedNode.width + 50;
                        y = State.ui.selectedNode.y;
                        
                        // Create edge from selected to new node
                        const newNode = State.addNode({ x, y });
                        State.addEdge(State.ui.selectedNode.id, newNode.id);
                        State.selectNode(newNode);
                    } else {
                        // Create node at center if no selection
                        const newNode = State.addNode({ 
                            x, y, 
                            name: META.templates.welcome.nodeName,
                            content: META.templates.welcome.nodeContent
                        });
                        State.selectNode(newNode);
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.created(State.ui.selectedNode.id));
                },
                
                /**
                 * Handles updating a node
                 */
                handleUpdateNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get values from editor
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    
                    // Update node
                    State.updateNode(State.ui.selectedNode.id, {
                        name: nameEl.value,
                        content: contentEl.value
                    });
                },
                
                /**
                 * Handles resizing a node
                 * @param {string} dimension - Dimension to resize ('width' or 'height')
                 * @param {number} delta - Amount to change dimension
                 */
                handleResizeNode: function(dimension, delta) {
                    if (!State.ui.selectedNode) return;
                    
                    const node = State.ui.selectedNode;
                    const constraints = META.node.constraints;
                    
                    // Apply resize with constraints
                    if (dimension === 'width') {
                        const newWidth = node.width + delta;
                        node.width = Math.max(constraints.minWidth, Math.min(constraints.maxWidth, newWidth));
                    } else if (dimension === 'height') {
                        const newHeight = node.height + delta;
                        node.height = Math.max(constraints.minHeight, Math.min(constraints.maxHeight, newHeight));
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.resized(dimension));
                },
                
                /**
                 * Handles toggling node style
                 */
                handleToggleStyle: function() {
                    if (!State.ui.selectedNode) return;
                    
                    const node = State.ui.selectedNode;
                    const styles = Object.keys(META.nodeStyles);
                    
                    // Find current style index
                    const currentIndex = styles.indexOf(node.style);
                    
                    // Get next style (or circle back to first)
                    const nextIndex = (currentIndex + 1) % styles.length;
                    node.style = styles[nextIndex];
                    
                    Renderer.draw();
                    UI.updateStatus(`Style changed to ${META.nodeStyles[node.style].name}`);
                }
            };
            
            // =====================================================================
            // 🔬 SOURCE EXPLORER: Browser-Based Code Exploration
            // =====================================================================

            /**
             * 🔬 Source Explorer: Interactive code navigation
             * 
             * This module transforms every emoji in the application into a "knowledge portal"
             * that opens a new browser tab showing the source code. It enables developers
             * to directly connect the UI they're experiencing with the implementation
             * behind it.
             * 
             * By making the relationship between interface and implementation explicit
             * and accessible, it embodies constructivist principles of learning through
             * direct exploration.
             */
            const SourceExplorer = {
                /**
                 * Initialize the Source Explorer
                 * Sets up emoji click handlers
                 */
                init: function() {
                    if (!META.sourceExplorer.enabled) return;
                    
                    // Add click handlers to all emoji explorer elements
                    this.setupEmojiPortals();
                    
                    // Add help button handler
                    DOM.elements['help-btn'].addEventListener('click', this.showHelp);
                    
                    Debug.log('Source Explorer initialized');
                },
                
                /**
                 * Set up all emoji portals in the UI
                 */
                setupEmojiPortals: function() {
                    // Find all emoji portal elements
                    const emojiElements = document.querySelectorAll(META.sourceExplorer.selector);
                    
                    // Add click handler to each
                    emojiElements.forEach(element => {
                        element.addEventListener('click', (e) => {
                            // Prevent the event from triggering parent elements
                            e.stopPropagation();
                            
                            // Get the emoji
                            const emoji = element.textContent.trim();
                            
                            // Open source explorer for this emoji
                            this.openSourceTab(emoji);
                        });
                    });
                    
                    Debug.log(`Set up ${emojiElements.length} emoji portals`);
                },
                
                /**
                 * Open a new browser tab with the source code
                 * @param {string} emoji - Emoji to search for
                 */
                openSourceTab: function(emoji) {
                    Debug.log(`Opening source tab for emoji: ${emoji}`);
                    
                    // Get the current page's source
                    const currentUrl = window.location.href;
                    
                    // Use view-source protocol with the current URL
                    const sourceUrl = `view-source:${currentUrl}`;
                    
                    // Open in a new tab - this will show the source code
                    // Note: The ability to scroll to the specific emoji will depend
                    // on browser support, as view-source doesn't support fragments
                    window.open(sourceUrl, '_blank');
                    
                    // Show a status message with instructions
                    UI.updateStatus(`Opened source code in new tab. Find "${emoji}" using Ctrl+F`, 5000);
                },
                
                /**
                 * Show help information
                 */
                showHelp: function() {
                    // Create an alert explaining how to use the Source Explorer
                    const helpText = `🔬 Source Explorer Help\n\n` +
                                    `Every emoji in this application is a "knowledge portal" ` +
                                    `that connects the interface to its implementation.\n\n` +
                                    `• Hover over any emoji to see what part of the system it represents\n` +
                                    `• Click any emoji to open a new tab with the source code\n` +
                                    `• Use your browser's find feature (Ctrl+F) to locate the emoji in the source\n\n` +
                                    `This allows you to directly explore how the application works by examining ` +
                                    `the code behind the features you're interested in.`;
                    
                    alert(helpText);
                }
            };
            
            // =====================================================================
            // 📤 EXPORT: Data Export Functionality
            // =====================================================================

            /**
             * 📤 ExportManager: Data export system
             * 
             * This module handles exporting graph data to different formats,
             * allowing users to save their work and share it with others.
             * 
             * By centralizing export logic, we ensure consistent export formats
             * and avoid duplication of code.
             */
            const ExportManager = {
                /**
                 * Exports graph to JSON
                 */
                toJson: function() {
                    // Create a copy of the graph data
                    const graphData = JSON.stringify(State.graph, null, 2);
                    
                    // Download as file
                    this.downloadFile(graphData, 'nodepad.json', META.export.formats.json.contentType);
                    UI.updateStatus(META.templates.status.exported('JSON'));
                },
                
                /**
                 * Exports graph to CSV files
                 */
                toCsv: function() {
                    // Create nodes CSV
                    const nodeHeader = 'id,name,content,x,y,width,height,style\n';
                    const nodeRows = State.graph.nodes.map(node => {
                        // Escape content for CSV
                        const escapedContent = `"${node.content.replace(/"/g, '""')}"`;
                        const escapedName = `"${(node.name || '').replace(/"/g, '""')}"`;
                        
                        return `${node.id},${escapedName},${escapedContent},${node.x},${node.y},${node.width},${node.height},${node.style}`;
                    }).join('\n');
                    
                    const nodesCSV = nodeHeader + nodeRows;
                    
                    // Create edges CSV
                    const edgeHeader = 'id,sourceId,targetId\n';
                    const edgeRows = State.graph.edges.map(edge => {
                        return `${edge.id},${edge.sourceId},${edge.targetId}`;
                    }).join('\n');
                    
                    const edgesCSV = edgeHeader + edgeRows;
                    
                    // Download both files
                    this.downloadFile(nodesCSV, META.export.formats.nodeCsv.filename, META.export.formats.nodeCsv.contentType);
                    this.downloadFile(edgesCSV, META.export.formats.edgeCsv.filename, META.export.formats.edgeCsv.contentType);
                    
                    UI.updateStatus(META.templates.status.exported('CSV'));
                },
                
                /**
                 * Creates and triggers download for a file
                 * @param {string} content - File content
                 * @param {string} fileName - File name
                 * @param {string} contentType - File MIME type
                 */
                downloadFile: function(content, fileName, contentType) {
                    // Create blob and download link
                    const blob = new Blob([content], { type: contentType });
                    const url = URL.createObjectURL(blob);
                    
                    // Create and trigger download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    
                    // Cleanup
                    URL.revokeObjectURL(url);
                }
            };
            
            // =====================================================================
            // 🐛 DEBUG: Debugging Utilities
            // =====================================================================

            /**
             * 🐛 Debug: Debugging toolkit
             * 
             * This module provides consistent debugging output and error handling,
             * making it easier to understand what's happening in the application
             * during development and troubleshooting.
             * 
             * By centralizing debug functions, we ensure consistent logging formats
             * and can easily enable or disable debug output.
             */
            const Debug = {
                /**
                 * Logs a debug message
                 * @param {string} message - Message to log
                 * @param {string} [level='info'] - Log level
                 */
                log: function(message, level = 'info') {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels[level] || META.debug.levels.info;
                    console.log(`${emoji} ${prefix} v${META.version.number}: ${message}`);
                },
                
                /**
                 * Logs an error message
                 * @param {string} message - Error message
                 * @param {Error} [error] - Error object
                 */
                error: function(message, error) {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels.error;
                    console.error(`${emoji} ${prefix} v${META.version.number}: ${message}`, error || '');
                },
                
                /**
                 * Logs a success message
                 * @param {string} message - Success message
                 */
                success: function(message) {
                    this.log(message, 'success');
                }
            };
            
            // =====================================================================
            // 🚀 APP: Application Initialization
            // =====================================================================

            /**
             * 🚀 App: Main application controller
             * 
             * This module handles the initialization and startup of the application,
             * ensuring all components are properly set up and connected.
             * 
             * It serves as the entry point and central coordinator for the
             * application's lifecycle.
             */
            const App = {
                /**
                 * Initializes the application
                 */
                init: function() {
                    // Initialize DOM references
                    DOM.init();
                    
                    // Set up event handlers
                    InputHandler.init();
                    
                    // Create initial node if no nodes exist
                    if (State.graph.nodes.length === 0) {
                        InputHandler.handleAddNode();
                    }
                    
                    // Render initial state
                    Renderer.draw();
                    
                    Debug.success('Application initialized');
                    UI.updateStatus(`Welcome to NodePad v${META.version.number}!`);
                    
                    return this;
                }
            };
            
            // =====================================================================
            // Initialize the application when DOM is loaded
            // =====================================================================
            
            // Start the application
            App.init();
        });
    </script>
</body>
</html>