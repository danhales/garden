<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodePad v1.🌳1.0</title>
    <!-- 
        NodePad v1.🌳1.0: Visual Knowledge Network
        
        Version History:
        v0.0.1 - Initial implementation with popup editor and basic node display
        v0.0.2 - Attempted to refactor with Node class architecture (contained bugs)
        v0.0.3 - Fixed edge rendering bug and simplified architecture
        v0.0.4 - Restructured code with proper DocTrellis versioning and modularized components
        v0.0.5 - Fixed node interaction bug with dragging different nodes
        v0.0.6 - Implemented template-based node rendering system
        v0.0.7 - Added ability to edit node names
        v0.1.0 - First minor version with stable core features and cleaned documentation
        v1.0.0 - Complete constructivist rewrite with knot-compacted architecture
        v1.🪴1.0 - Simplified circular nodes with emoji identifiers and hover information
        v1.🌿1.1 - Enhanced node display with emoji/title toggle and fixed emoji picker width
        v1.🌳1.0 - Stable release with independent emoji/title controls, node coloring, smart positioning,
                 node removal, and JSON import functionality
        
        DocTrellis Feature Status:
        🌳 Core Architecture - Tree - Constructivist template system with metadata-driven design
        🌳 Node Management - Tree - Create, select, edit, remove, and drag nodes
        🌿 Edge Connections - Herb - Connections between nodes
        🌳 Network View - Tree - Canvas-based visualization with independent emoji/title display options
        🌿 Node Customization - Herb - Colors and emoji selection for visual organization
        🌱 Import/Export - Seedling - JSON export and import functionality
        
        Leaf Pile (Pruned Features):
        🍂 CSV Export - Removed to simplify data handling
        🍂 Source Explorer - Browser-based source code exploration using emoji markers
        🍂 Custom node styles - Multiple visual presentation options for node content
        🍂 Static Tooltips - Replaced with more contextual information displays
        🍂 Fixed Node Sizing - Replaced with dynamic sizing based on content and display mode
    -->
    <style>
        /* Base Variables - Single Source of Truth */
        :root {
            /* Color Palette */
            --color-bg: #fafafa;
            --color-surface: #ffffff;
            --color-surface-alt: #f5f5f5;
            --color-border: #dddddd;
            --color-text: #333333;
            --color-text-muted: #666666;
            --color-primary: #1890ff;
            --color-primary-dark: #096dd9;
            --color-primary-light: #e6f7ff;
            --color-success: #52c41a;
            --color-warning: #faad14;
            --color-error: #f5222d;
            
            /* Spacing System */
            --space-unit: 8px;
            --space-xs: calc(var(--space-unit) * 0.5);  /* 4px */
            --space-sm: var(--space-unit);              /* 8px */
            --space-md: calc(var(--space-unit) * 2);    /* 16px */
            --space-lg: calc(var(--space-unit) * 3);    /* 24px */
            --space-xl: calc(var(--space-unit) * 4);    /* 32px */
            
            /* Typography */
            --font-family: Arial, sans-serif;
            --font-size-base: 14px;
            --font-size-sm: 12px;
            --font-size-lg: 16px;
            --font-weight-normal: 400;
            --font-weight-bold: 600;
            --line-height: 1.6;
            
            /* Layout */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            
            /* Transitions */
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            
            /* Node dimensions */
            --node-size: 60px;
            --node-emoji-size: 24px;
            
            /* Animation */
            --animation-duration: 300ms;
            --animation-easing: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            color: var(--color-text);
            background-color: var(--color-bg);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Application Layout */
        .header {
            background-color: var(--color-surface);
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            margin: 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .version {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
            font-weight: var(--font-weight-normal);
            margin-left: var(--space-sm);
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--color-bg);
        }
        
        #network-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .editor-container {
            width: 40%;
            display: flex;
            flex-direction: column;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            overflow: hidden;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: var(--space-sm);
            flex-wrap: wrap;
        }
        
        button {
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-surface-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            font-size: var(--font-size-base);
            transition: background-color var(--transition-fast);
            white-space: nowrap;
        }
        
        button:hover {
            background-color: var(--color-border);
        }
        
        button:active {
            background-color: var(--color-border);
        }
        
        button.primary {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        button.primary:hover {
            background-color: var(--color-primary-dark);
        }
        
        button.danger {
            background-color: var(--color-error);
            color: white;
            border-color: var(--color-error);
        }
        
        button.danger:hover {
            background-color: #d9363e;
        }
        
        /* Editor Styles */
        .editor-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            background-color: var(--color-surface-alt);
        }
        
        .editor-title {
            margin: 0 0 var(--space-xs) 0;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-bold);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .node-emoji {
            font-size: 1.2em;
        }

        .unused-class {
            font-size: 1em;
        }
        
        .editor-subtitle {
            color: var(--color-text-muted);
            font-size: var(--font-size-base);
            margin: 0;
        }
        
        .editor-content {
            flex: 1;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-placeholder {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-muted);
            font-style: italic;
            text-align: center;
            padding: var(--space-lg);
        }
        
        .name-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        .emoji-input-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
        }
        
        .emoji-label, .color-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: var(--font-weight-bold);
            color: var(--color-text-muted);
        }
        
        #node-emoji-select {
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-lg);
            min-width: 60px;
            cursor: pointer;
        }
        
        #node-name {
            width: 100%;
            padding: var(--space-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            transition: border-color var(--transition-fast);
        }
        
        #node-name:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        #node-content {
            flex: 1;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            font-family: inherit;
            font-size: var(--font-size-base);
            line-height: var(--line-height);
            resize: none;
            margin-bottom: var(--space-md);
        }
        
        #node-content:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }
        
        .editor-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Node tooltip */
        .node-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-sm);
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity var(--transition-fast);
            max-width: 200px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Status Indicator */
        .status {
            position: absolute;
            bottom: var(--space-sm);
            left: var(--space-sm);
            background: rgba(255, 255, 255, 0.8);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-base);
            color: var(--color-text-muted);
        }

        /* Emoji picker dialog */
        .emoji-picker {
            position: absolute;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            padding: var(--space-md);
            z-index: 100;
            /* Dynamic width will be calculated in JS */
            display: none;
        }
        
        .emoji-picker.active {
            display: block;
        }
        
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }
        
        .emoji-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            border-radius: var(--border-radius-sm);
        }
        
        .emoji-item:hover {
            background-color: var(--color-surface-alt);
        }
        
        /* Color picker styles */
        .color-picker {
            position: absolute;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            padding: var(--space-md);
            z-index: 100;
            display: none;
            width: 280px;
        }
        
        .color-picker.active {
            display: block;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-sm);
            margin-bottom: var(--space-sm);
        }
        
        .color-item {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid var(--color-border);
            transition: transform var(--transition-fast);
        }
        
        .color-item:hover {
            transform: scale(1.1);
        }
        
        .color-item.active {
            border: 2px solid var(--color-primary);
        }
        
        .custom-color-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-top: var(--space-md);
        }
        
        #custom-color {
            padding: 0;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-sm);
            width: 30px;
            height: 30px;
            cursor: pointer;
        }
        
        /* Display mode toggles */
        .display-toggles {
            display: flex;
            gap: var(--space-md);
            align-items: center;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--color-border);
            border-radius: 10px;
            transition: var(--transition-fast);
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            border-radius: 50%;
            transition: var(--transition-fast);
        }
        
        input:checked + .toggle-slider {
            background-color: var(--color-primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        .toggle-label {
            font-size: var(--font-size-sm);
            color: var(--color-text-muted);
        }
        
        /* Node color selector */
        .color-select-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        #node-color-select {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid var(--color-border);
            cursor: pointer;
        }
        
        /* File import styles */
        .file-input {
            display: none;
        }
        
        /* Responsive styles */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .editor-container {
                width: 100%;
                height: 40%;
                border-left: none;
                border-top: 1px solid var(--color-border);
            }
            
            .controls {
                flex-wrap: wrap;
            }
        }
        
        /* Node removal confirmation modal */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal);
        }
        
        .modal-backdrop.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal {
            background-color: var(--color-surface);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            width: 400px;
            max-width: 90%;
            transform: translateY(-20px);
            transition: transform var(--transition-normal);
        }
        
        .modal-backdrop.active .modal {
            transform: translateY(0);
        }
        
        .modal-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
        }
        
        .modal-title {
            margin: 0;
            font-size: var(--font-size-lg);
            color: var(--color-error);
        }
        
        .modal-body {
            padding: var(--space-md);
        }
        
        .modal-footer {
            padding: var(--space-md);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">📝 NodePad <span class="version">v1.🌳1.0</span></h1>
        <div class="controls">
            <button id="add-node-btn">Add Node</button>
            <div class="display-toggles">
                <div class="toggle-container">
                    <span class="toggle-label">Emoji</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="emoji-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">Titles</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="title-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            <button id="export-json-btn">Export JSON</button>
            <button id="import-json-btn">Import JSON</button>
            <input type="file" id="import-file" class="file-input" accept=".json">
        </div>
    </div>
    
    <div class="main-container">
        <!-- Network View (Left Side) -->
        <div class="canvas-container">
            <canvas id="network-canvas"></canvas>
            <div class="node-tooltip" id="node-tooltip"></div>
            <div class="status" id="status">Ready</div>
        </div>
        
        <!-- Node Editor (Right Side) -->
        <div class="editor-container">
            <div class="editor-header">
                <h2 class="editor-title" id="editor-title">Node Editor</h2>
                <p class="editor-subtitle" id="editor-subtitle">Select a node to edit its content</p>
            </div>
            
            <div class="editor-content" id="editor-content">
                <div class="editor-placeholder" id="editor-placeholder">
                    Click on a node in the network view to edit its content
                </div>
                
                <div class="emoji-input-container">
                    <div>
                        <label class="emoji-label" for="node-emoji-select">Node Icon:</label>
                        <button id="node-emoji-select">🌱</button>
                    </div>
                    <div class="color-select-container">
                        <label class="color-label" for="node-color-select">Color:</label>
                        <div id="node-color-select" style="background-color: #ffffff;"></div>
                    </div>
                    <div style="flex: 1;">
                        <label class="name-label" for="node-name">Node Title:</label>
                        <input type="text" id="node-name" placeholder="Enter a title for this node">
                    </div>
                </div>
                
                <textarea id="node-content" placeholder="Enter your notes here..."></textarea>
                
                <div class="editor-actions">
                    <button id="remove-node-btn" class="danger">Remove Node</button>
                    <button id="update-node-btn" class="primary">Update Node</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Emoji Picker Dialog -->
    <div class="emoji-picker" id="emoji-picker">
        <h3>Select an Emoji</h3>
        <div class="emoji-grid" id="emoji-grid"></div>
    </div>
    
    <!-- Color Picker Dialog -->
    <div class="color-picker" id="color-picker">
        <h3>Select a Color</h3>
        <div class="color-grid" id="color-grid"></div>
        <div class="custom-color-container">
            <label for="custom-color">Custom color:</label>
            <input type="color" id="custom-color" value="#ffffff">
        </div>
    </div>
    
    <!-- Confirmation Modal for Node Removal -->
    <div class="modal-backdrop" id="remove-confirmation-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Remove Node?</h3>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to remove this node and all its connections? This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button id="cancel-remove-btn">Cancel</button>
                <button id="confirm-remove-btn" class="danger">Remove</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * NodePad v1.🌳1.0: Visual Knowledge Network
         * 
         * A nonlinear note-taking application that represents ideas as 
         * interconnected nodes in a visual network, making it easier to
         * organize complex thoughts and relationships.
         * 
         * @version 1.🌳1.0
         */
        
        document.addEventListener('DOMContentLoaded', function() {
            // =====================================================================
            // META-SYSTEM: Application Metadata and Configuration
            // =====================================================================

            /**
             * META: Application knowledge system
             * 
             * Centralized configuration that serves as a single source of truth
             * for all application parameters.
             * 
             * @version 1.🌳1.0 - Enhanced with independent display controls and color options
             */
            const META = {
                /** Application version information */
                version: {
                    number: '1.🌳1.0',
                    name: 'Visual Knowledge Network',
                    date: '2025-03-31'
                },
                
                /** Debug configuration */
                debug: {
                    enabled: true,
                    prefix: 'NodePad',
                    levels: {
                        info: 'ℹ️',
                        warn: '⚠️',
                        error: '❌',
                        success: '✅'
                    }
                },
                
                /** Node configuration */
                node: {
                    defaults: {
                        size: 60,
                        emoji: '🌱',
                        content: '',
                        color: '#ffffff' // Default white background
                    },
                    selected: {
                        outlineWidth: 3,
                        outlineColor: '#1890ff'
                    },
                    dragThreshold: 5,  // Pixels of movement needed to start dragging
                    
                    // Display configuration with independent controls
                    display: {
                        emojiVisible: true,
                        titleVisible: false,
                        transition: {
                            duration: 300, // ms
                            easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
                        },
                        title: {
                            fontSize: 0.3, // proportion of node size
                            minWidth: 1.0, // proportion of node size
                            padding: 0.25 // proportion of node size
                        },
                        emoji: {
                            size: 0.4 // proportion of node size
                        }
                    },
                    
                    // Positioning logic
                    positioning: {
                        // Horizontal spacing (for compact emoji view)
                        horizontalOffset: 2, // multiplier of node size
                        // Vertical spacing (for expanded title view)
                        verticalOffset: 1.5, // multiplier of node size
                    },
                    
                    // Color options
                    colors: [
                        '#ffffff', // White (default)
                        '#f0f4c3', // Light yellow
                        '#c8e6c9', // Light green
                        '#bbdefb', // Light blue
                        '#d1c4e9', // Light purple
                        '#ffccbc', // Light orange
                        '#ffcdd2', // Light red
                        '#e1bee7', // Light pink
                        '#b2dfdb', // Light teal
                        '#f5f5f5'  // Light gray
                    ]
                },
                
                /** Edge configuration */
                edge: {
                    style: {
                        color: '#d9d9d9',
                        width: 1,
                        selectedColor: '#1890ff',
                        selectedWidth: 2
                    }
                },
                
                /** Export/Import configuration */
                dataTransfer: {
                    formats: {
                        json: {
                            extension: 'json',
                            contentType: 'application/json',
                            filename: 'nodepad-network.json'
                        }
                    }
                },
                
                /** Emoji picker configuration */
                emojiPicker: {
                    emojis: [
                        '🌱', '🌿', '🌳', '🍂', '🔮', '📝', '💡', '🔍', 
                        '📊', '📈', '📉', '📌', '🔖', '📚', '🗂️', '📋',
                        '✅', '❌', '⚠️', '❓', '❗', '💬', '🗨️', '🔄',
                        '🧩', '⚙️', '🔧', '🔨', '⏱️', '📅', '🧠', '❤️'
                    ],
                    columns: 8, // Number of columns in the grid
                    itemSize: 30, // Size of each emoji item in pixels
                    padding: 16 // Padding inside the container in pixels
                },
                
                /** Animation configuration */
                animation: {
                    duration: 300, // ms
                    easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
                },
                
                /** Templates for static text */
                templates: {
                    welcome: {
                        emoji: '📝',
                        name: 'Welcome to NodePad!',
                        content: 'This is your first note in your visual knowledge network.\n\n• Click nodes to edit their content\n• Drag nodes to rearrange them\n• Connect nodes to show relationships\n• Customize nodes with colors and emojis\n• Toggle between emoji and title views\n\nStart organizing your ideas!',
                        color: '#bbdefb' // Light blue for welcome node
                    },
                    status: {
                        ready: 'Ready',
                        selected: nodeName => `Selected: ${nodeName}`,
                        created: nodeName => `Created: ${nodeName}`,
                        updated: nodeName => `Updated: ${nodeName}`,
                        removed: nodeName => `Removed: ${nodeName}`,
                        exported: format => `Exported ${format} file`,
                        imported: fileInfo => `Imported ${fileInfo}`,
                        displayChanged: mode => `Display mode updated`
                    },
                    modals: {
                        removeNode: {
                            title: 'Remove Node?',
                            message: 'Are you sure you want to remove this node and all its connections? This action cannot be undone.',
                            cancel: 'Cancel',
                            confirm: 'Remove'
                        }
                    }
                }
            };
            
            // =====================================================================
            // TEMPLATES: Reusable Object Factories
            // =====================================================================

            /**
             * Templates: Object factory system
             * 
             * Provides consistent patterns for creating application objects
             * like nodes and edges.
             * 
             * @version 1.🌳1.0 - Enhanced with color support for nodes
             */
            const Templates = {
                /**
                 * Creates a new node with specified properties
                 * @param {Object} props - Properties to override defaults
                 * @returns {Object} A new node object
                 */
                createNode: function(props = {}) {
                    const id = props.id || `node-${State.counters.nextNodeId++}`;
                    
                    return {
                        id: id,
                        emoji: props.emoji || META.node.defaults.emoji,
                        name: props.name || '',
                        content: props.content || META.node.defaults.content,
                        color: props.color || META.node.defaults.color,
                        x: props.x || 0,
                        y: props.y || 0,
                        size: props.size || META.node.defaults.size
                    };
                },
                
                /**
                 * Creates a new edge between two nodes
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} A new edge object
                 */
                createEdge: function(sourceId, targetId) {
                    return {
                        id: `edge-${State.counters.nextEdgeId++}`,
                        sourceId: sourceId,
                        targetId: targetId
                    };
                }
            };
            
            // =====================================================================
            // STATE: Global Application State
            // =====================================================================

            /**
             * State: Global application state management
             * 
             * Centralizes all application data and state management functions.
             * 
             * @version 1.🌳1.0 - Enhanced with independent display controls, node removal, and import/export
             */
            const State = {
                /** Graph data containing nodes and edges */
                graph: {
                    nodes: [],
                    edges: []
                },
                
                /** UI state information */
                ui: {
                    selectedNode: null,
                    isDragging: false,
                    draggedNode: null,
                    dragStartX: 0,
                    dragStartY: 0,
                    dragOffsetX: 0,
                    dragOffsetY: 0,
                    hoveredNode: null,
                    
                    // New display state with independent controls
                    display: {
                        showEmoji: META.node.display.emojiVisible,
                        showTitle: META.node.display.titleVisible,
                        isTransitioning: false,
                        transitionStartTime: 0,
                        animationId: null
                    }
                },
                
                /** Global counters */
                counters: {
                    nextNodeId: 1,
                    nextEdgeId: 1
                },
                
                /**
                 * Selects a node and updates UI accordingly
                 * @param {Object|null} node - Node to select or null to deselect
                 */
                selectNode: function(node) {
                    this.ui.selectedNode = node;
                    UI.updateEditor(node);
                    Renderer.draw();
                    
                    if (node) {
                        UI.updateStatus(META.templates.status.selected(node.name || 'Untitled Node'));
                    } else {
                        UI.updateStatus(META.templates.status.ready);
                    }
                },
                
                /**
                 * Adds a new node to the graph
                 * @param {Object} nodeProps - Properties for the new node
                 * @returns {Object} The created node
                 */
                addNode: function(nodeProps) {
                    const node = Templates.createNode(nodeProps);
                    this.graph.nodes.push(node);
                    return node;
                },
                
                /**
                 * Removes a node and all its connected edges
                 * @param {string} nodeId - ID of node to remove
                 * @returns {boolean} Success status
                 */
                removeNode: function(nodeId) {
                    // Find the node
                    const nodeIndex = this.graph.nodes.findIndex(n => n.id === nodeId);
                    if (nodeIndex === -1) return false;
                    
                    // Get node name for status update
                    const nodeName = this.graph.nodes[nodeIndex].name || 'Untitled Node';
                    
                    // Remove all connected edges
                    this.graph.edges = this.graph.edges.filter(edge => 
                        edge.sourceId !== nodeId && edge.targetId !== nodeId
                    );
                    
                    // Remove the node
                    this.graph.nodes.splice(nodeIndex, 1);
                    
                    // Update selection if removed node was selected
                    if (this.ui.selectedNode && this.ui.selectedNode.id === nodeId) {
                        this.selectNode(null);
                    }
                    
                    // Update display
                    Renderer.draw();
                    
                    // Update status
                    UI.updateStatus(META.templates.status.removed(nodeName));
                    
                    return true;
                },
                
                /**
                 * Connects two nodes with an edge
                 * @param {string} sourceId - ID of source node
                 * @param {string} targetId - ID of target node
                 * @returns {Object} The created edge
                 */
                addEdge: function(sourceId, targetId) {
                    const edge = Templates.createEdge(sourceId, targetId);
                    this.graph.edges.push(edge);
                    return edge;
                },
                
                /**
                 * Finds a node at the specified coordinates
                 * @param {number} x - X coordinate
                 * @param {number} y - Y coordinate
                 * @returns {Object|null} Node at coordinates or null if none found
                 */
                findNodeAt: function(x, y) {
                    // Search from front to back (later nodes appear on top)
                    for (let i = this.graph.nodes.length - 1; i >= 0; i--) {
                        const node = this.graph.nodes[i];
                        
                        // Calculate node dimensions based on display mode
                        const dimensions = this.calculateNodeDimensions(node);
                        
                        // Simple rectangle collision check
                        if (x >= dimensions.left && x <= dimensions.right && 
                            y >= dimensions.top && y <= dimensions.bottom) {
                            // Additional check for rounded corners
                            const radius = dimensions.height / 2;
                            
                            // Check if in corner regions
                            if (dimensions.isRounded) {
                                // Check corners for rectangular nodes
                                if (x < dimensions.left + radius && y < dimensions.top + radius) {
                                    // Top-left corner
                                    const cornerX = dimensions.left + radius;
                                    const cornerY = dimensions.top + radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                                else if (x > dimensions.right - radius && y < dimensions.top + radius) {
                                    // Top-right corner
                                    const cornerX = dimensions.right - radius;
                                    const cornerY = dimensions.top + radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                                else if (x < dimensions.left + radius && y > dimensions.bottom - radius) {
                                    // Bottom-left corner
                                    const cornerX = dimensions.left + radius;
                                    const cornerY = dimensions.bottom - radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                                else if (x > dimensions.right - radius && y > dimensions.bottom - radius) {
                                    // Bottom-right corner
                                    const cornerX = dimensions.right - radius;
                                    const cornerY = dimensions.bottom - radius;
                                    const dx = x - cornerX;
                                    const dy = y - cornerY;
                                    if (Math.sqrt(dx * dx + dy * dy) > radius) continue;
                                }
                            } else if (dimensions.isCircular) {
                                // Calculate distance from center for circular nodes
                                const centerX = (dimensions.left + dimensions.right) / 2;
                                const centerY = (dimensions.top + dimensions.bottom) / 2;
                                const dx = x - centerX;
                                const dy = y - centerY;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance > radius) continue;
                            }
                            
                            return node;
                        }
                    }
                    return null;
                },
                
                /**
                 * Calculate node dimensions based on display mode
                 * @param {Object} node - Node to calculate dimensions for
                 * @returns {Object} Node dimension information including bounds and shape
                 */
                calculateNodeDimensions: function(node) {
                    const centerX = node.x + node.size / 2;
                    const centerY = node.y + node.size / 2;
                    
                    // Calculate based on current display mode
                    const showEmoji = this.ui.display.showEmoji;
                    const showTitle = this.ui.display.showTitle;
                    
                    // Both emoji and title
                    if (showEmoji && showTitle) {
                        // Measure text
                        const canvas = DOM.canvas;
                        const ctx = DOM.ctx;
                        const fontSize = node.size * META.node.display.title.fontSize;
                        ctx.font = `${fontSize}px ${window.getComputedStyle(document.body).fontFamily}`;
                        const textWidth = ctx.measureText(node.name || 'Untitled').width;
                        
                        // Calculate dimensions
                        const padding = node.size * META.node.display.title.padding;
                        const minWidth = node.size;
                        const width = Math.max(minWidth, textWidth + padding * 2);
                        const height = node.size;
                        
                        // Calculate bounds
                        return {
                            left: centerX - width / 2,
                            right: centerX + width / 2,
                            top: centerY - height / 2,
                            bottom: centerY + height / 2,
                            width: width,
                            height: height,
                            isRounded: true,
                            isCircular: false
                        };
                    } 
                    // Only emoji
                    else if (showEmoji && !showTitle) {
                        // Circular node
                        const radius = node.size / 2;
                        return {
                            left: centerX - radius,
                            right: centerX + radius,
                            top: centerY - radius,
                            bottom: centerY + radius,
                            width: node.size,
                            height: node.size,
                            isRounded: false,
                            isCircular: true
                        };
                    }
                    // Only title
                    else if (!showEmoji && showTitle) {
                        // Text-only node
                        const canvas = DOM.canvas;
                        const ctx = DOM.ctx;
                        const fontSize = node.size * META.node.display.title.fontSize;
                        ctx.font = `${fontSize}px ${window.getComputedStyle(document.body).fontFamily}`;
                        const textWidth = ctx.measureText(node.name || 'Untitled').width;
                        
                        // Calculate dimensions
                        const padding = node.size * META.node.display.title.padding;
                        const minWidth = node.size * 0.8; // Slightly smaller than emoji node
                        const width = Math.max(minWidth, textWidth + padding * 2);
                        const height = node.size * 0.7; // Smaller height for text-only
                        
                        // Calculate bounds
                        return {
                            left: centerX - width / 2,
                            right: centerX + width / 2,
                            top: centerY - height / 2,
                            bottom: centerY + height / 2,
                            width: width,
                            height: height,
                            isRounded: true,
                            isCircular: false
                        };
                    }
                    // Default: minimal node (fallback if both disabled)
                    else {
                        // Small dot node
                        const smallRadius = node.size / 3;
                        return {
                            left: centerX - smallRadius,
                            right: centerX + smallRadius,
                            top: centerY - smallRadius,
                            bottom: centerY + smallRadius,
                            width: smallRadius * 2,
                            height: smallRadius * 2,
                            isRounded: false,
                            isCircular: true
                        };
                    }
                },
                
                /**
                 * Updates node properties
                 * @param {string} nodeId - ID of node to update
                 * @param {Object} changes - Properties to update
                 */
                updateNode: function(nodeId, changes) {
                    const node = this.graph.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    // Apply changes
                    Object.assign(node, changes);
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.updated(node.name || 'Untitled Node'));
                },
                
                /**
                 * Toggles emoji display
                 * @param {boolean} visible - Whether emoji should be visible
                 */
                toggleEmojiDisplay: function(visible) {
                    if (this.ui.display.showEmoji === visible) return;
                    
                    this.ui.display.showEmoji = visible;
                    
                    // Check that at least one display mode is enabled
                    if (!this.ui.display.showEmoji && !this.ui.display.showTitle) {
                        // Enable title mode if trying to hide both
                        this.ui.display.showTitle = true;
                        UI.updateDisplayToggles();
                    }
                    
                    // Start transition animation
                    this.startDisplayTransition();
                    
                    UI.updateStatus(META.templates.status.displayChanged('emoji: ' + visible));
                },
                
                /**
                 * Toggles title display
                 * @param {boolean} visible - Whether titles should be visible
                 */
                toggleTitleDisplay: function(visible) {
                    if (this.ui.display.showTitle === visible) return;
                    
                    this.ui.display.showTitle = visible;
                    
                    // Check that at least one display mode is enabled
                    if (!this.ui.display.showEmoji && !this.ui.display.showTitle) {
                        // Enable emoji mode if trying to hide both
                        this.ui.display.showEmoji = true;
                        UI.updateDisplayToggles();
                    }
                    
                    // Start transition animation
                    this.startDisplayTransition();
                    
                    UI.updateStatus(META.templates.status.displayChanged('title: ' + visible));
                },
                
                /**
                 * Starts display transition animation
                 */
                startDisplayTransition: function() {
                    // Set up animation state
                    this.ui.display.isTransitioning = true;
                    this.ui.display.transitionStartTime = performance.now();
                    
                    // Start animation if not already running
                    if (!this.ui.display.animationId) {
                        this.ui.display.animationId = requestAnimationFrame(() => this.animateDisplayTransition());
                    }
                },
                
                /**
                 * Animate transition between display modes
                 */
                animateDisplayTransition: function() {
                    const now = performance.now();
                    const elapsed = now - this.ui.display.transitionStartTime;
                    const progress = Math.min(elapsed / META.animation.duration, 1);
                    
                    // Use easing function for smoother animation
                    const easedProgress = this.easeInOutCubic(progress);
                    
                    // Draw current frame with transition progress
                    Renderer.draw(easedProgress);
                    
                    if (progress < 1) {
                        // Continue animation
                        this.ui.display.animationId = requestAnimationFrame(() => this.animateDisplayTransition());
                    } else {
                        // End transition
                        this.ui.display.isTransitioning = false;
                        this.ui.display.animationId = null;
                        Renderer.draw(); // Final frame
                    }
                },
                
                /**
                 * Easing function for smooth transitions
                 * @param {number} t - Progress from 0 to 1
                 * @returns {number} Eased value
                 */
                easeInOutCubic: function(t) {
                    return t < 0.5
                        ? 4 * t * t * t
                        : 1 - Math.pow(-2 * t + 2, 3) / 2;
                },
                
                /**
                 * Exports graph data to JSON
                 */
                exportData: function() {
                    TransferManager.exportJson();
                },
                
                /**
                 * Imports graph data from JSON
                 * @param {File} file - JSON file to import
                 */
                importData: function(file) {
                    TransferManager.importJson(file);
                },
                
                /**
                 * Resets the application state
                 * @param {Object} newData - Optional new data to initialize with
                 */
                reset: function(newData = null) {
                    // Clear current state
                    this.graph.nodes = [];
                    this.graph.edges = [];
                    this.selectNode(null);
                    
                    // Initialize with new data if provided
                    if (newData) {
                        // Reset counters
                        if (newData.nodes && newData.nodes.length > 0) {
                            // Find highest ID numbers and set counters accordingly
                            const nodeIds = newData.nodes
                                .map(n => parseInt(n.id.replace('node-', '')))
                                .filter(id => !isNaN(id));
                            
                            if (nodeIds.length > 0) {
                                this.counters.nextNodeId = Math.max(...nodeIds) + 1;
                            }
                        }
                        
                        if (newData.edges && newData.edges.length > 0) {
                            const edgeIds = newData.edges
                                .map(e => parseInt(e.id.replace('edge-', '')))
                                .filter(id => !isNaN(id));
                            
                            if (edgeIds.length > 0) {
                                this.counters.nextEdgeId = Math.max(...edgeIds) + 1;
                            }
                        }
                        
                        // Copy nodes and edges
                        if (newData.nodes) {
                            // Ensure all nodes have required properties
                            this.graph.nodes = newData.nodes.map(node => {
                                // Apply defaults for missing properties
                                return {
                                    id: node.id,
                                    emoji: node.emoji || META.node.defaults.emoji,
                                    name: node.name || '',
                                    content: node.content || '',
                                    color: node.color || META.node.defaults.color,
                                    x: node.x || 0,
                                    y: node.y || 0,
                                    size: node.size || META.node.defaults.size
                                };
                            });
                        }
                        
                        if (newData.edges) {
                            this.graph.edges = [...newData.edges];
                        }
                    }
                    
                    // Redraw
                    Renderer.draw();
                }
            };
            
            // =====================================================================
            // DOM: Interface to DOM Elements
            // =====================================================================

            /**
             * DOM: Centralized DOM access
             * 
             * Provides a single interface to all DOM elements used by the application.
             * 
             * @version 1.🌳1.0 - Enhanced with color picker and display toggles
             */
            const DOM = {
                /** Element references */
                elements: {},
                
                /** Canvas element and context */
                canvas: null,
                ctx: null,
                
                /**
                 * Initializes DOM references
                 * Gathers all necessary DOM elements into a single access point
                 */
                init: function() {
                    // Core elements
                    const ids = [
                        'network-canvas', 'add-node-btn', 'export-json-btn', 'import-json-btn',
                        'node-name', 'node-content', 'update-node-btn', 'remove-node-btn', 'editor-title',
                        'editor-subtitle', 'editor-placeholder', 'status', 'node-tooltip',
                        'node-emoji-select', 'emoji-picker', 'emoji-grid', 'emoji-toggle', 'title-toggle',
                        'node-color-select', 'color-picker', 'color-grid', 'custom-color',
                        'import-file', 'remove-confirmation-modal', 'cancel-remove-btn', 'confirm-remove-btn'
                    ];
                    
                    // Populate elements object
                    ids.forEach(id => {
                        this.elements[id] = document.getElementById(id);
                    });
                    
                    // Setup canvas and context
                    this.canvas = this.elements['network-canvas'];
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Ensure canvas is properly sized
                    this.resizeCanvas();
                    
                    // Initialize pickers
                    this.initEmojiPicker();
                    this.initColorPicker();
                },
                
                /**
                 * Sets the canvas size to match its container
                 */
                resizeCanvas: function() {
                    const container = document.querySelector('.canvas-container');
                    this.canvas.width = container.offsetWidth;
                    this.canvas.height = container.offsetHeight;
                },
                
                /**
                 * Initialize emoji picker with available options
                 */
                initEmojiPicker: function() {
                    const grid = this.elements['emoji-grid'];
                    const picker = this.elements['emoji-picker'];
                    if (!grid || !picker) return;
                    
                    // Clear existing items
                    grid.innerHTML = '';
                    
                    // Add all emojis
                    META.emojiPicker.emojis.forEach(emoji => {
                        const item = document.createElement('div');
                        item.className = 'emoji-item';
                        item.textContent = emoji;
                        item.setAttribute('data-emoji', emoji);
                        item.addEventListener('click', () => {
                            if (State.ui.selectedNode) {
                                // Update the emoji select button
                                this.elements['node-emoji-select'].textContent = emoji;
                                
                                // Hide the picker
                                picker.classList.remove('active');
                            }
                        });
                        
                        grid.appendChild(item);
                    });
                    
                    // Calculate and set picker width dynamically
                    const columns = META.emojiPicker.columns;
                    const itemSize = META.emojiPicker.itemSize;
                    const gapSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--space-sm'));
                    const paddingSize = META.emojiPicker.padding * 2;
                    
                    // Width = (columns * itemSize) + (gaps between items) + (padding on both sides)
                    const totalWidth = (columns * itemSize) + ((columns - 1) * gapSize) + paddingSize;
                    picker.style.width = `${totalWidth}px`;
                    
                    // Set up emoji select button
                    const emojiSelect = this.elements['node-emoji-select'];
                    
                    if (emojiSelect && picker) {
                        emojiSelect.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // Position the picker near the button
                            const rect = emojiSelect.getBoundingClientRect();
                            picker.style.top = `${rect.bottom + 5}px`;
                            picker.style.left = `${rect.left}px`;
                            
                            // Toggle visibility
                            picker.classList.toggle('active');
                            
                            // Hide color picker if open
                            const colorPicker = this.elements['color-picker'];
                            if (colorPicker) {
                                colorPicker.classList.remove('active');
                            }
                        });
                    }
                },
                
                /**
                 * Initialize color picker with palette and custom color option
                 */
                initColorPicker: function() {
                    const grid = this.elements['color-grid'];
                    const picker = this.elements['color-picker'];
                    const customColor = this.elements['custom-color'];
                    
                    if (!grid || !picker) return;
                    
                    // Clear existing items
                    grid.innerHTML = '';
                    
                    // Add color palette
                    META.node.colors.forEach(color => {
                        const item = document.createElement('div');
                        item.className = 'color-item';
                        item.style.backgroundColor = color;
                        item.setAttribute('data-color', color);
                        item.addEventListener('click', () => {
                            if (State.ui.selectedNode) {
                                // Update the color select button
                                this.elements['node-color-select'].style.backgroundColor = color;
                                
                                // Update custom color input
                                if (customColor) {
                                    customColor.value = color;
                                }
                                
                                // Hide the picker
                                picker.classList.remove('active');
                            }
                        });
                        
                        grid.appendChild(item);
                    });
                    
                    // Set up custom color input
                    if (customColor) {
                        customColor.addEventListener('input', (e) => {
                            // Update color select when custom color changes
                            const color = e.target.value;
                            this.elements['node-color-select'].style.backgroundColor = color;
                        });
                    }
                    
                    // Set up color select button
                    const colorSelect = this.elements['node-color-select'];
                    
                    if (colorSelect && picker) {
                        colorSelect.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // Position the picker near the button
                            const rect = colorSelect.getBoundingClientRect();
                            picker.style.top = `${rect.bottom + 5}px`;
                            picker.style.left = `${rect.left}px`;
                            
                            // Toggle visibility
                            picker.classList.toggle('active');
                            
                            // Hide emoji picker if open
                            const emojiPicker = this.elements['emoji-picker'];
                            if (emojiPicker) {
                                emojiPicker.classList.remove('active');
                            }
                        });
                    }
                },
                
                /**
                 * Check if an emoji is supported in the current browser
                 * @param {string} emoji - Emoji character to check
                 * @returns {boolean} True if emoji is likely supported
                 */
                isEmojiSupported: function(emoji) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Use a large enough font size
                    ctx.font = '20px sans-serif';
                    
                    // Try to draw the emoji
                    ctx.fillText(emoji, 0, 0);
                    
                    // Check if pixel data is not empty
                    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    
                    // Check if any pixel has alpha > 0
                    for (let i = 3; i < data.length; i += 4) {
                        if (data[i] > 0) return true;
                    }
                    
                    return false;
                },
                
                /**
                 * Show a confirmation modal
                 * @param {string} modalId - ID of modal to show
                 */
                showModal: function(modalId) {
                    const modal = this.elements[modalId];
                    if (modal) {
                        modal.classList.add('active');
                    }
                },
                
                /**
                 * Hide a confirmation modal
                 * @param {string} modalId - ID of modal to hide
                 */
                hideModal: function(modalId) {
                    const modal = this.elements[modalId];
                    if (modal) {
                        modal.classList.remove('active');
                    }
                }
            };
            
            // =====================================================================
            // UI: User Interface Management
            // =====================================================================

            /**
             * UI: User interface controller
             * 
             * Handles all updates to the user interface based on application state.
             * 
             * @version 1.🌳1.0 - Enhanced with color selection and display toggles
             */
            const UI = {
                /**
                 * Updates the node editor with node content
                 * @param {Object|null} node - Node to edit or null to clear editor
                 */
                updateEditor: function(node) {
                    const placeholderEl = DOM.elements['editor-placeholder'];
                    const emojiSelectEl = DOM.elements['node-emoji-select'];
                    const colorSelectEl = DOM.elements['node-color-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    const titleEl = DOM.elements['editor-title'];
                    const subtitleEl = DOM.elements['editor-subtitle'];
                    const updateBtnEl = DOM.elements['update-node-btn'];
                    const removeBtnEl = DOM.elements['remove-node-btn'];
                    const emojiPickerEl = DOM.elements['emoji-picker'];
                    const colorPickerEl = DOM.elements['color-picker'];
                    
                    // Hide pickers if open
                    if (emojiPickerEl) {
                        emojiPickerEl.classList.remove('active');
                    }
                    if (colorPickerEl) {
                        colorPickerEl.classList.remove('active');
                    }
                    
                    if (node) {
                        // Show editor with node content
                        placeholderEl.style.display = 'none';
                        nameEl.style.display = 'block';
                        contentEl.style.display = 'block';
                        updateBtnEl.style.display = 'block';
                        removeBtnEl.style.display = 'block';
                        emojiSelectEl.parentElement.parentElement.style.display = 'flex';
                        
                        // Set content
                        emojiSelectEl.textContent = node.emoji;
                        colorSelectEl.style.backgroundColor = node.color || META.node.defaults.color;
                        nameEl.value = node.name || '';
                        contentEl.value = node.content || '';
                        
                        // Update custom color input if it exists
                        const customColorEl = DOM.elements['custom-color'];
                        if (customColorEl) {
                            customColorEl.value = node.color || META.node.defaults.color;
                        }
                        
                        // Update headings
                        titleEl.innerHTML = `<span class="node-emoji">${node.emoji}</span> Editing ${node.name || 'Untitled Node'}`;
                        subtitleEl.textContent = 'Make changes and click "Update Node" to save';
                    } else {
                        // Hide editor, show placeholder
                        placeholderEl.style.display = 'flex';
                        nameEl.style.display = 'none';
                        contentEl.style.display = 'none';
                        updateBtnEl.style.display = 'none';
                        removeBtnEl.style.display = 'none';
                        emojiSelectEl.parentElement.parentElement.style.display = 'none';
                        
                        // Update headings
                        titleEl.textContent = 'Node Editor';
                        subtitleEl.textContent = 'Select a node to edit its content';
                    }
                },
                
                /**
                 * Update display toggle switches to match current state
                 */
                updateDisplayToggles: function() {
                    const emojiToggle = DOM.elements['emoji-toggle'];
                    const titleToggle = DOM.elements['title-toggle'];
                    
                    if (emojiToggle) {
                        emojiToggle.checked = State.ui.display.showEmoji;
                    }
                    
                    if (titleToggle) {
                        titleToggle.checked = State.ui.display.showTitle;
                    }
                },
                
                /**
                 * Show node tooltip at specified position
                 * @param {Object} node - Node to show tooltip for
                 * @param {number} x - X position
                 * @param {number} y - Y position 
                 */
                showNodeTooltip: function(node, x, y) {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    // Set tooltip content (adaptive based on what's already visible)
                    let content = '';
                    
                    if (State.ui.display.showEmoji && State.ui.display.showTitle) {
                        // Both visible, show content preview
                        content = node.content ? node.content.substring(0, 30) + (node.content.length > 30 ? '...' : '') : 'No content';
                    } else if (State.ui.display.showEmoji && !State.ui.display.showTitle) {
                        // Only emoji visible, show name
                        content = node.name || 'Untitled Node';
                    } else if (!State.ui.display.showEmoji && State.ui.display.showTitle) {
                        // Only title visible, show emoji
                        content = node.emoji;
                    } else {
                        // Neither visible (shouldn't happen), show both
                        content = `${node.emoji} ${node.name || 'Untitled Node'}`;
                    }
                    
                    // Set tooltip content and position
                    tooltip.textContent = content;
                    tooltip.style.left = `${x}px`;
                    tooltip.style.top = `${y - 30}px`;
                    tooltip.style.opacity = '1';
                    
                    // Update hovered node reference
                    State.ui.hoveredNode = node;
                },
                
                /**
                 * Hide node tooltip
                 */
                hideNodeTooltip: function() {
                    const tooltip = DOM.elements['node-tooltip'];
                    if (!tooltip) return;
                    
                    tooltip.style.opacity = '0';
                    State.ui.hoveredNode = null;
                },
                
                /**
                 * Updates the status message
                 * @param {string} message - Status message to display
                 * @param {number} [duration=3000] - Duration to show message in ms
                 */
                updateStatus: function(message, duration = 3000) {
                    const statusEl = DOM.elements.status;
                    if (!statusEl) return;
                    
                    // Set message
                    statusEl.textContent = message;
                    Debug.log(`Status: ${message}`);
                    
                    // Clear after duration
                    setTimeout(() => {
                        if (statusEl.textContent === message) {
                            statusEl.textContent = State.ui.selectedNode ? 
                                META.templates.status.selected(State.ui.selectedNode.name || 'Untitled Node') : 
                                META.templates.status.ready;
                        }
                    }, duration);
                }
            };
            
            // =====================================================================
            // RENDERER: Canvas Drawing System
            // =====================================================================

            /**
             * Renderer: Visual drawing system
             * 
             * Handles all drawing operations on the canvas, visualizing
             * the nodes and edges in the network.
             * 
             * @version 1.🌳1.0 - Enhanced with color support and display modes
             */
            const Renderer = {
                /**
                 * Draws the complete graph
                 * @param {number} [transitionProgress=null] - Optional transition progress (0-1)
                 */
                draw: function(transitionProgress = null) {
                    const ctx = DOM.ctx;
                    const canvas = DOM.canvas;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw all edges
                    this.drawEdges();
                    
                    // Draw all nodes
                    this.drawNodes(transitionProgress);
                },
                
                /**
                 * Draws all edges in the graph
                 */
                drawEdges: function() {
                    const ctx = DOM.ctx;
                    const edges = State.graph.edges;
                    
                    // Set default edge style
                    ctx.strokeStyle = META.edge.style.color;
                    ctx.lineWidth = META.edge.style.width;
                    
                    edges.forEach(edge => {
                        // Find connected nodes
                        const sourceNode = State.graph.nodes.find(n => n.id === edge.sourceId);
                        const targetNode = State.graph.nodes.find(n => n.id === edge.targetId);
                        
                        // Skip if either node is missing
                        if (!sourceNode || !targetNode) return;
                        
                        // Calculate connection points (center of nodes)
                        const sourceX = sourceNode.x + sourceNode.size / 2;
                        const sourceY = sourceNode.y + sourceNode.size / 2;
                        const targetX = targetNode.x + targetNode.size / 2;
                        const targetY = targetNode.y + targetNode.size / 2;
                        
                        // Draw connecting line
                        ctx.beginPath();
                        ctx.moveTo(sourceX, sourceY);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                    });
                },
                
                /**
                 * Draws all nodes in the graph
                 * @param {number} [transitionProgress=null] - Optional transition progress (0-1)
                 */
                drawNodes: function(transitionProgress = null) {
                    const nodes = State.graph.nodes;
                    
                    nodes.forEach(node => {
                        this.drawNode(node, transitionProgress);
                    });
                },
                
                /**
                 * Draws a single node
                 * @param {Object} node - Node to draw
                 * @param {number} [transitionProgress=null] - Optional transition progress (0-1)
                 */
                drawNode: function(node, transitionProgress = null) {
                    const ctx = DOM.ctx;
                    const isSelected = node === State.ui.selectedNode;
                    
                    // Calculate center position
                    const centerX = node.x + node.size / 2;
                    const centerY = node.y + node.size / 2;
                    
                    // Get current display mode
                    const showEmoji = State.ui.display.showEmoji;
                    const showTitle = State.ui.display.showTitle;
                    
                    // Check if we're in transition
                    const isTransitioning = State.ui.display.isTransitioning && transitionProgress !== null;
                    
                    if (isTransitioning) {
                        // Draw transition between display modes
                        this.drawNodeTransition(node, centerX, centerY, isSelected, transitionProgress);
                    } else {
                        // Draw based on current display mode
                        if (showEmoji && showTitle) {
                            // Both emoji and title
                            this.drawTitleNode(node, centerX, centerY, isSelected, true);
                        } else if (showEmoji && !showTitle) {
                            // Only emoji
                            this.drawEmojiNode(node, centerX, centerY, isSelected);
                        } else if (!showEmoji && showTitle) {
                            // Only title
                            this.drawTitleNode(node, centerX, centerY, isSelected, false);
                        } else {
                            // Fallback: minimal node (shouldn't happen in normal use)
                            this.drawMinimalNode(node, centerX, centerY, isSelected);
                        }
                    }
                },
                
                /**
                 * Draws node with emoji
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 */
                drawEmojiNode: function(node, centerX, centerY, isSelected) {
                    const ctx = DOM.ctx;
                    const radius = node.size / 2;
                    
                    // Draw node background circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    // Fill with node color
                    ctx.fillStyle = node.color || META.node.defaults.color;
                    ctx.fill();
                    
                    // Draw outline, thicker if selected
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#d9d9d9';
                        ctx.lineWidth = 1;
                    }
                    
                    ctx.stroke();
                    
                    // Draw emoji in center
                    const emojiSize = node.size * META.node.display.emoji.size;
                    ctx.font = `${emojiSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#333';
                    ctx.fillText(node.emoji, centerX, centerY);
                },
                
                /**
                 * Draws node with title (and optionally emoji)
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 * @param {boolean} showEmoji - Whether to include emoji
                 */
                drawTitleNode: function(node, centerX, centerY, isSelected, showEmoji) {
                    const ctx = DOM.ctx;
                    
                    // Calculate dimensions
                    const height = showEmoji ? node.size : node.size * 0.7;
                    const radius = height / 2;
                    
                    // Measure text
                    const fontSize = node.size * META.node.display.title.fontSize;
                    ctx.font = `${fontSize}px ${window.getComputedStyle(document.body).fontFamily}`;
                    const title = node.name || 'Untitled';
                    const textMetrics = ctx.measureText(title);
                    const textWidth = textMetrics.width;
                    
                    // Calculate width (minimum is the node size)
                    const padding = node.size * META.node.display.title.padding;
                    const minWidth = showEmoji ? node.size : node.size * 0.8;
                    const width = Math.max(minWidth, textWidth + padding * 2);
                    
                    // Calculate top-left corner position
                    const x = centerX - width / 2;
                    const y = centerY - height / 2;
                    
                    // Draw rounded rectangle
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.arcTo(x + width, y, x + width, y + radius, radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
                    ctx.lineTo(x + radius, y + height);
                    ctx.arcTo(x, y + height, x, y + height - radius, radius);
                    ctx.lineTo(x, y + radius);
                    ctx.arcTo(x, y, x + radius, y, radius);
                    ctx.closePath();
                    
                    // Fill with node color
                    ctx.fillStyle = node.color || META.node.defaults.color;
                    ctx.fill();
                    
                    // Draw outline
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#d9d9d9';
                        ctx.lineWidth = 1;
                    }
                    ctx.stroke();
                    
                    // Draw title text
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(title, centerX, centerY);
                    
                    // Draw emoji if showing both
                    if (showEmoji) {
                        // Draw small emoji indicator in top left
                        const emojiSize = node.size * 0.2;
                        ctx.font = `${emojiSize}px Arial`;
                        ctx.fillText(node.emoji, x + emojiSize, y + emojiSize);
                    }
                },
                
                /**
                 * Draws a minimal node (fallback for when neither emoji nor title is shown)
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 */
                drawMinimalNode: function(node, centerX, centerY, isSelected) {
                    const ctx = DOM.ctx;
                    const radius = node.size / 3; // Smaller than regular nodes
                    
                    // Draw node background circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    // Fill with node color or darker version to make it visible
                    ctx.fillStyle = node.color || '#bbdefb'; // Make default more visible
                    ctx.fill();
                    
                    // Draw outline, thicker if selected
                    if (isSelected) {
                        ctx.strokeStyle = META.node.selected.outlineColor;
                        ctx.lineWidth = META.node.selected.outlineWidth;
                    } else {
                        ctx.strokeStyle = '#777777'; // Darker for visibility
                        ctx.lineWidth = 1.5;
                    }
                    
                    ctx.stroke();
                },
                
                /**
                 * Draws node transitioning between display modes
                 * @param {Object} node - Node to draw
                 * @param {number} centerX - Center X position
                 * @param {number} centerY - Center Y position
                 * @param {boolean} isSelected - Whether node is selected
                 * @param {number} progress - Transition progress (0-1)
                 */
                drawNodeTransition: function(node, centerX, centerY, isSelected, progress) {
                    const ctx = DOM.ctx;
                    
                    // Get current display state
                    const showEmoji = State.ui.display.showEmoji;
                    const showTitle = State.ui.display.showTitle;
                    
                    // Determine transition type based on current state
                    if (showEmoji && showTitle) {
                        // Transitioning to showing both
                        // Draw title node with fading in emoji
                        ctx.globalAlpha = progress;
                        this.drawTitleNode(node, centerX, centerY, isSelected, true);
                        ctx.globalAlpha = 1;
                        
                        // Draw fading emoji node
                        ctx.globalAlpha = 1 - progress;
                        if (!showTitle) {
                            // Coming from emoji-only
                            this.drawEmojiNode(node, centerX, centerY, isSelected);
                        } else {
                            // Coming from title-only
                            this.drawTitleNode(node, centerX, centerY, isSelected, false);
                        }
                        ctx.globalAlpha = 1;
                    } else if (showEmoji && !showTitle) {
                        // Transitioning to emoji-only
                        ctx.globalAlpha = progress;
                        this.drawEmojiNode(node, centerX, centerY, isSelected);
                        ctx.globalAlpha = 1;
                        
                        // Fade out previous mode
                        ctx.globalAlpha = 1 - progress;
                        this.drawTitleNode(node, centerX, centerY, isSelected, !showEmoji);
                        ctx.globalAlpha = 1;
                    } else if (!showEmoji && showTitle) {
                        // Transitioning to title-only
                        ctx.globalAlpha = progress;
                        this.drawTitleNode(node, centerX, centerY, isSelected, false);
                        ctx.globalAlpha = 1;
                        
                        // Fade out previous mode
                        ctx.globalAlpha = 1 - progress;
                        this.drawEmojiNode(node, centerX, centerY, isSelected);
                        ctx.globalAlpha = 1;
                    } else {
                        // This shouldn't happen in normal operation
                        this.drawMinimalNode(node, centerX, centerY, isSelected);
                    }
                }
            };
            
            // =====================================================================
            // INPUT: User Interaction Handler
            // =====================================================================

            /**
             * InputHandler: Interaction management
             * 
             * Handles all user interactions with the application,
             * including mouse events, keyboard input, and button clicks.
             * 
             * @version 1.🌳1.0 - Enhanced with display toggles, node removal, and import/export
             */
            const InputHandler = {
                /**
                 * Sets up all event listeners
                 */
                init: function() {
                    // Canvas mouse events
                    DOM.canvas.addEventListener('mousedown', this.handleMouseDown);
                    DOM.canvas.addEventListener('mousemove', this.handleMouseMove);
                    DOM.canvas.addEventListener('mouseup', this.handleMouseUp);
                    DOM.canvas.addEventListener('click', this.handleClick);
                    
                    // Button events
                    DOM.elements['add-node-btn'].addEventListener('click', this.handleAddNode);
                    DOM.elements['update-node-btn'].addEventListener('click', this.handleUpdateNode);
                    DOM.elements['remove-node-btn'].addEventListener('click', this.handleRemoveNodePrompt);
                    DOM.elements['export-json-btn'].addEventListener('click', () => State.exportData());
                    DOM.elements['import-json-btn'].addEventListener('click', this.handleImportButtonClick);
                    
                    // File import handling
                    DOM.elements['import-file'].addEventListener('change', this.handleFileImport);
                    
                    // Display toggle events
                    DOM.elements['emoji-toggle'].addEventListener('change', (e) => {
                        State.toggleEmojiDisplay(e.target.checked);
                    });
                    
                    DOM.elements['title-toggle'].addEventListener('change', (e) => {
                        State.toggleTitleDisplay(e.target.checked);
                    });
                    
                    // Removal confirmation modal events
                    DOM.elements['cancel-remove-btn'].addEventListener('click', () => {
                        DOM.hideModal('remove-confirmation-modal');
                    });
                    
                    DOM.elements['confirm-remove-btn'].addEventListener('click', this.handleRemoveNode);
                    
                    // Document-level click handler to close pickers
                    document.addEventListener('click', (e) => {
                        // Close pickers when clicking outside
                        const emojiPicker = DOM.elements['emoji-picker'];
                        const colorPicker = DOM.elements['color-picker'];
                        const emojiButton = DOM.elements['node-emoji-select'];
                        const colorButton = DOM.elements['node-color-select'];
                        
                        if (emojiPicker && e.target !== emojiButton && !emojiPicker.contains(e.target)) {
                            emojiPicker.classList.remove('active');
                        }
                        
                        if (colorPicker && e.target !== colorButton && !colorPicker.contains(e.target)) {
                            colorPicker.classList.remove('active');
                        }
                    });
                    
                    // Window resize event
                    window.addEventListener('resize', () => {
                        DOM.resizeCanvas();
                        Renderer.draw();
                    });
                },
                
                /**
                 * Handles mouse down event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseDown: function(e) {
                    // Get mouse position relative to canvas
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find node under cursor
                    const node = State.findNodeAt(x, y);
                    
                    if (node) {
                        // Set drag start position
                        State.ui.dragStartX = x;
                        State.ui.dragStartY = y;
                        State.ui.draggedNode = node;
                        
                        // Calculate offset from the top-left corner of the node
                        State.ui.dragOffsetX = x - node.x;
                        State.ui.dragOffsetY = y - node.y;
                        
                        // Don't set isDragging yet - wait for movement threshold
                        
                        // Change cursor
                        DOM.canvas.style.cursor = 'grabbing';
                    }
                },
                
                /**
                 * Handles mouse move event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleMouseMove: function(e) {
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Handle dragging - wait for movement threshold
                    if (State.ui.draggedNode) {
                        // Check if we've moved enough to start dragging
                        const dragDistance = Math.sqrt(
                            Math.pow(x - State.ui.dragStartX, 2) + 
                            Math.pow(y - State.ui.dragStartY, 2)
                        );
                        
                        if (dragDistance >= META.node.dragThreshold || State.ui.isDragging) {
                            // Start dragging if we haven't already
                            State.ui.isDragging = true;
                            
                            // Update node position
                            State.ui.draggedNode.x = x - State.ui.dragOffsetX;
                            State.ui.draggedNode.y = y - State.ui.dragOffsetY;
                            Renderer.draw();
                        }
                    } else {
                        // Check for node hovering for tooltip
                        const hoveredNode = State.findNodeAt(x, y);
                        
                        if (hoveredNode) {
                            // Show tooltip
                            UI.showNodeTooltip(hoveredNode, x, y);
                            // Update cursor
                            DOM.canvas.style.cursor = 'grab';
                        } else {
                            // Hide tooltip
                            UI.hideNodeTooltip();
                            // Reset cursor
                            DOM.canvas.style.cursor = 'default';
                        }
                    }
                },
                
                /**
                 * Handles mouse up event
                 */
                handleMouseUp: function() {
                    // End dragging
                    State.ui.isDragging = false;
                    State.ui.draggedNode = null;
                    
                    // Reset cursor
                    DOM.canvas.style.cursor = 'default';
                },
                
                /**
                 * Handles mouse click event
                 * @param {MouseEvent} e - Mouse event
                 */
                handleClick: function(e) {
                    // Ignore if we were dragging
                    if (State.ui.isDragging) return;
                    
                    // Get mouse position
                    const rect = DOM.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Find and select node
                    const node = State.findNodeAt(x, y);
                    State.selectNode(node);
                },
                
                /**
                 * Handles adding a new node
                 */
                handleAddNode: function() {
                    // Calculate position for new node
                    const canvas = DOM.canvas;
                    const nodeSize = META.node.defaults.size;
                    const centerX = canvas.width / 2 - nodeSize / 2;
                    const centerY = canvas.height / 2 - nodeSize / 2;
                    
                    // Add offset if there's a selected node
                    let x = centerX;
                    let y = centerY;
                    
                    if (State.ui.selectedNode) {
                        // Smart positioning based on display mode
                        if (State.ui.display.showTitle) {
                            // Vertical positioning for title mode (below parent)
                            const verticalOffset = META.node.positioning.verticalOffset;
                            const dimensions = State.calculateNodeDimensions(State.ui.selectedNode);
                            
                            x = State.ui.selectedNode.x;
                            y = State.ui.selectedNode.y + dimensions.height + nodeSize * verticalOffset;
                        } else {
                            // Horizontal positioning for emoji mode (beside parent)
                            const horizontalOffset = META.node.positioning.horizontalOffset;
                            x = State.ui.selectedNode.x + nodeSize * horizontalOffset;
                            y = State.ui.selectedNode.y;
                        }
                        
                        // Create edge from selected to new node
                        const newNode = State.addNode({ x, y });
                        State.addEdge(State.ui.selectedNode.id, newNode.id);
                        State.selectNode(newNode);
                    } else {
                        // Create welcome node at center if no selection
                        const welcomeNode = State.addNode({ 
                            x, y, 
                            emoji: META.templates.welcome.emoji,
                            name: META.templates.welcome.name,
                            content: META.templates.welcome.content,
                            color: META.templates.welcome.color
                        });
                        State.selectNode(welcomeNode);
                    }
                    
                    Renderer.draw();
                    UI.updateStatus(META.templates.status.created(State.ui.selectedNode.name || 'Untitled Node'));
                },
                
                /**
                 * Handles updating a node
                 */
                handleUpdateNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get values from editor
                    const emojiEl = DOM.elements['node-emoji-select'];
                    const colorEl = DOM.elements['node-color-select'];
                    const nameEl = DOM.elements['node-name'];
                    const contentEl = DOM.elements['node-content'];
                    
                    // Update node
                    State.updateNode(State.ui.selectedNode.id, {
                        emoji: emojiEl.textContent,
                        color: colorEl.style.backgroundColor,
                        name: nameEl.value,
                        content: contentEl.value
                    });
                    
                    // Update editor title
                    const titleEl = DOM.elements['editor-title'];
                    titleEl.innerHTML = `<span class="node-emoji">${emojiEl.textContent}</span> Editing ${nameEl.value || 'Untitled Node'}`;
                },
                
                /**
                 * Shows node removal confirmation prompt
                 */
                handleRemoveNodePrompt: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Show confirmation modal
                    DOM.showModal('remove-confirmation-modal');
                },
                
                /**
                 * Handles removing a node after confirmation
                 */
                handleRemoveNode: function() {
                    if (!State.ui.selectedNode) return;
                    
                    // Get node name for status update
                    const nodeName = State.ui.selectedNode.name || 'Untitled Node';
                    
                    // Remove the node
                    State.removeNode(State.ui.selectedNode.id);
                    
                    // Hide the confirmation modal
                    DOM.hideModal('remove-confirmation-modal');
                    
                    // Update status
                    UI.updateStatus(META.templates.status.removed(nodeName));
                },
                
                /**
                 * Handles clicking the import button
                 */
                handleImportButtonClick: function() {
                    // Trigger file input click
                    DOM.elements['import-file'].click();
                },
                
                /**
                 * Handles file import
                 * @param {Event} e - Change event
                 */
                handleFileImport: function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    // Check file type
                    if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                        UI.updateStatus('Error: Please select a JSON file', 5000);
                        return;
                    }
                    
                    // Import data from file
                    State.importData(file);
                    
                    // Reset file input
                    e.target.value = '';
                }
            };
            
            // =====================================================================
            // TRANSFER MANAGER: Import and Export Functionality
            // =====================================================================

            /**
             * TransferManager: Data import and export system
             * 
             * Handles transferring graph data in and out of the application.
             * 
             * @version 1.🌳1.0 - Enhanced with JSON import functionality
             */
            const TransferManager = {
                /**
                 * Exports graph to JSON
                 */
                exportJson: function() {
                    // Create a copy of the graph data
                    const graphData = JSON.stringify(State.graph, null, 2);
                    
                    // Download as file
                    this.downloadFile(
                        graphData, 
                        META.dataTransfer.formats.json.filename, 
                        META.dataTransfer.formats.json.contentType
                    );
                    UI.updateStatus(META.templates.status.exported('JSON'));
                },
                
                /**
                 * Imports graph from JSON file
                 * @param {File} file - JSON file to import
                 */
                importJson: function(file) {
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        try {
                            // Parse JSON data
                            const jsonData = JSON.parse(e.target.result);
                            
                            // Validate data structure
                            if (!jsonData.nodes || !Array.isArray(jsonData.nodes) ||
                                !jsonData.edges || !Array.isArray(jsonData.edges)) {
                                throw new Error('Invalid JSON format: Missing nodes or edges arrays');
                            }
                            
                            // Reset application state with new data
                            State.reset(jsonData);
                            
                            // Update status
                            UI.updateStatus(META.templates.status.imported(`${jsonData.nodes.length} nodes, ${jsonData.edges.length} edges`));
                        } catch (error) {
                            Debug.error('Import error:', error);
                            UI.updateStatus(`Error: ${error.message}`, 5000);
                        }
                    };
                    
                    reader.onerror = function() {
                        UI.updateStatus('Error: Failed to read file', 5000);
                    };
                    
                    reader.readAsText(file);
                },
                
                /**
                 * Creates and triggers download for a file
                 * @param {string} content - File content
                 * @param {string} fileName - File name
                 * @param {string} contentType - File MIME type
                 */
                downloadFile: function(content, fileName, contentType) {
                    // Create blob and download link
                    const blob = new Blob([content], { type: contentType });
                    const url = URL.createObjectURL(blob);
                    
                    // Create and trigger download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    
                    // Cleanup
                    URL.revokeObjectURL(url);
                }
            };
            
            // =====================================================================
            // DEBUG: Debugging Utilities
            // =====================================================================

            /**
             * Debug: Debugging toolkit
             * 
             * Provides consistent debugging output and error handling.
             * 
             * @version 1.🌳1.0 - Maintained from previous version
             */
            const Debug = {
                /**
                 * Logs a debug message
                 * @param {string} message - Message to log
                 * @param {string} [level='info'] - Log level
                 */
                log: function(message, level = 'info') {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels[level] || META.debug.levels.info;
                    console.log(`${emoji} ${prefix} v${META.version.number}: ${message}`);
                },
                
                /**
                 * Logs an error message
                 * @param {string} message - Error message
                 * @param {Error} [error] - Error object
                 */
                error: function(message, error) {
                    if (!META.debug.enabled) return;
                    
                    const prefix = META.debug.prefix;
                    const emoji = META.debug.levels.error;
                    console.error(`${emoji} ${prefix} v${META.version.number}: ${message}`, error || '');
                },
                
                /**
                 * Logs a success message
                 * @param {string} message - Success message
                 */
                success: function(message) {
                    this.log(message, 'success');
                }
            };
            
            // =====================================================================
            // APP: Application Initialization
            // =====================================================================

            /**
             * App: Main application controller
             * 
             * Handles the initialization and startup of the application.
             * 
             * @version 1.🌳1.0 - Enhanced with independent display controls
             */
            const App = {
                /**
                 * Initializes the application
                 */
                init: function() {
                    // Initialize DOM references
                    DOM.init();
                    
                    // Set up event handlers
                    InputHandler.init();
                    
                    // Set display toggles to match state
                    UI.updateDisplayToggles();
                    
                    // Create initial node if no nodes exist
                    if (State.graph.nodes.length === 0) {
                        InputHandler.handleAddNode();
                    }
                    
                    // Check for emoji support
                    this.checkEmojiSupport();
                    
                    // Render initial state
                    Renderer.draw();
                    
                    Debug.success('Application initialized');
                    UI.updateStatus(`Welcome to NodePad v${META.version.number}!`);
                    
                    return this;
                },
                
                /**
                 * Check if emojis are supported in the current browser
                 * Falls back to simple symbols if needed
                 */
                checkEmojiSupport: function() {
                    // Test a few key emojis for support
                    const testEmojis = ['🌱', '🌿', '🌳', '🍂', '📝'];
                    let hasUnsupportedEmojis = false;
                    
                    // Simple feature detection for emoji support
                    testEmojis.forEach(emoji => {
                        if (!DOM.isEmojiSupported(emoji)) {
                            hasUnsupportedEmojis = true;
                            Debug.log(`Emoji not supported: ${emoji}`, 'warn');
                        }
                    });
                    
                    // If some emojis aren't supported, warn in debug
                    if (hasUnsupportedEmojis) {
                        Debug.log('Some emojis are not supported in this browser - consider using fallbacks', 'warn');
                    }
                }
            };
            
            // =====================================================================
            // Initialize the application when DOM is loaded
            // =====================================================================
            
            // Start the application
            App.init();
        });
    </script>
</body>
</html>